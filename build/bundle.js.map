{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../node_modules/style-inject/dist/style-inject.es.js","../../../node_modules/@splidejs/splide/dist/js/splide.esm.js","../../node_modules/svelte/store/index.mjs","../../../src/lib/store.js","../../../src/Splide.svelte","../../src/App.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value = ret) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? undefined : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction claim_element(nodes, name, attributes, svg) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeName === name) {\n            let j = 0;\n            const remove = [];\n            while (j < node.attributes.length) {\n                const attribute = node.attributes[j++];\n                if (!attributes[attribute.name]) {\n                    remove.push(attribute.name);\n                }\n            }\n            for (let k = 0; k < remove.length; k++) {\n                node.removeAttribute(remove[k]);\n            }\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return svg ? svg_element(name) : element(name);\n}\nfunction claim_text(nodes, data) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 3) {\n            node.data = '' + data;\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return text(data);\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    const z_index = (parseInt(computed_style.zIndex) || 0) - 1;\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', `display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ` +\n        `overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: ${z_index};`);\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = `data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>`;\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, false, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor(anchor = null) {\n        this.a = anchor;\n        this.e = this.n = null;\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.h(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = node.ownerDocument;\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error(`Function called outside component initialization`);\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        callbacks.slice().forEach(fn => fn(event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = program.b - t;\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            info.blocks[i] = null;\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error(`Cannot have duplicate keys in a keyed each`);\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += \" \" + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += \" \" + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${String(value).replace(/\"/g, '&#34;').replace(/'/g, '&#39;')}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, options = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, options);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : ``;\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    // onMount happens before the initial afterUpdate\n    add_render_callback(() => {\n        const new_on_destroy = on_mount.map(run).filter(is_function);\n        if (on_destroy) {\n            on_destroy.push(...new_on_destroy);\n        }\n        else {\n            // Edge case - component was destroyed immediately,\n            // most likely as a result of a binding initialising\n            run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n    });\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const prop_values = options.props || {};\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : []),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false\n    };\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, prop_values, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor);\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.24.1' }, detail)));\n}\nfunction append_dev(target, node) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node });\n    append(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev(\"SvelteDOMRemove\", { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? [\"capture\"] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev(\"SvelteDOMAddEventListener\", { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev(\"SvelteDOMRemoveEventListener\", { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev(\"SvelteDOMRemoveAttribute\", { node, attribute });\n    else\n        dispatch_dev(\"SvelteDOMSetAttribute\", { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev(\"SvelteDOMSetProperty\", { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev(\"SvelteDOMSetDataset\", { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev(\"SvelteDOMSetData\", { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(`'target' is a required option`);\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn(`Component was already destroyed`); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error(`Infinite loop detected`);\n        }\n    };\n}\n\nexport { HtmlTag, SvelteComponent, SvelteComponentDev, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, assign, attr, attr_dev, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_space, claim_text, clear_loops, component_subscribe, compute_rest_props, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, escape, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getContext, get_binding_group_value, get_current_component, get_slot_changes, get_slot_context, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, has_prop, identity, init, insert, insert_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, update_keyed_each, update_slot, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","/*!\n * Splide.js\n * Version  : 2.4.12\n * License  : MIT\n * Copyright: 2020 Naotoshi Fujita\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Splide\"] = factory();\n\telse\n\t\troot[\"Splide\"] = factory();\n})(window, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"default\", function() { return /* binding */ module_Splide; });\n\n// NAMESPACE OBJECT: ./src/js/constants/states.js\nvar states_namespaceObject = {};\n__webpack_require__.r(states_namespaceObject);\n__webpack_require__.d(states_namespaceObject, \"CREATED\", function() { return CREATED; });\n__webpack_require__.d(states_namespaceObject, \"MOUNTED\", function() { return MOUNTED; });\n__webpack_require__.d(states_namespaceObject, \"IDLE\", function() { return IDLE; });\n__webpack_require__.d(states_namespaceObject, \"MOVING\", function() { return MOVING; });\n__webpack_require__.d(states_namespaceObject, \"DESTROYED\", function() { return DESTROYED; });\n\n// CONCATENATED MODULE: ./src/js/core/event.js\n/**\r\n * The function for providing an Event object simply managing events.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The function for providing an Event object simply managing events.\r\n */\n/* harmony default export */ var core_event = (function () {\n  /**\r\n   * Store all event data.\r\n   *\r\n   * @type {Array}\r\n   */\n  var data = [];\n  var Event = {\n    /**\r\n     * Subscribe the given event(s).\r\n     *\r\n     * @param {string}   events  - An event name. Use space to separate multiple events.\r\n     *                             Also, namespace is accepted by dot, such as 'resize.{namespace}'.\r\n     * @param {function} handler - A callback function.\r\n     * @param {Element}  elm     - Optional. Native event will be listened to when this arg is provided.\r\n     * @param {Object}   options - Optional. Options for addEventListener.\r\n     */\n    on: function on(events, handler, elm, options) {\n      if (elm === void 0) {\n        elm = null;\n      }\n\n      if (options === void 0) {\n        options = {};\n      }\n\n      events.split(' ').forEach(function (event) {\n        if (elm) {\n          elm.addEventListener(event, handler, options);\n        }\n\n        data.push({\n          event: event,\n          handler: handler,\n          elm: elm,\n          options: options\n        });\n      });\n    },\n\n    /**\r\n     * Unsubscribe the given event(s).\r\n     *\r\n     * @param {string}  events - A event name or names split by space.\r\n     * @param {Element} elm    - Optional. removeEventListener() will be called when this arg is provided.\r\n     */\n    off: function off(events, elm) {\n      if (elm === void 0) {\n        elm = null;\n      }\n\n      events.split(' ').forEach(function (event) {\n        data = data.filter(function (item) {\n          if (item && item.event === event && item.elm === elm) {\n            unsubscribe(item);\n            return false;\n          }\n\n          return true;\n        });\n      });\n    },\n\n    /**\r\n     * Emit an event.\r\n     * This method is only for custom events.\r\n     *\r\n     * @param {string}  event - An event name.\r\n     * @param {*}       args  - Any number of arguments passed to handlers.\r\n     */\n    emit: function emit(event) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      data.forEach(function (item) {\n        if (!item.elm && item.event.split('.')[0] === event) {\n          item.handler.apply(item, args);\n        }\n      });\n    },\n\n    /**\r\n     * Clear event data.\r\n     */\n    destroy: function destroy() {\n      data.forEach(unsubscribe);\n      data = [];\n    }\n  };\n  /**\r\n   * Remove the registered event listener.\r\n   *\r\n   * @param {Object} item - An object containing event data.\r\n   */\n\n  function unsubscribe(item) {\n    if (item.elm) {\n      item.elm.removeEventListener(item.event, item.handler, item.options);\n    }\n  }\n\n  return Event;\n});\n// CONCATENATED MODULE: ./src/js/core/state.js\n/**\r\n * The function providing a super simple state system.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The function providing a super simple state system.\r\n *\r\n * @param {string|number} initialState - Provide the initial state value.\r\n */\n/* harmony default export */ var state = (function (initialState) {\n  /**\r\n   * Store the current state.\r\n   *\r\n   * @type {string|number}\r\n   */\n  var curr = initialState;\n  return {\n    /**\r\n     * Change state.\r\n     *\r\n     * @param {string|number} state - A new state.\r\n     */\n    set: function set(state) {\n      curr = state;\n    },\n\n    /**\r\n     * Verify if the current state is given one or not.\r\n     *\r\n     * @param {string|number} state - A state name to be verified.\r\n     *\r\n     * @return {boolean} - True if the current state is the given one.\r\n     */\n    is: function is(state) {\n      return state === curr;\n    }\n  };\n});\n// CONCATENATED MODULE: ./src/js/utils/object.js\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n/**\r\n * Some utility functions related with Object, supporting IE.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\nvar keys = Object.keys;\n/**\r\n * Iterate an object like Array.forEach.\r\n * IE doesn't support forEach of HTMLCollection.\r\n *\r\n * @param {Object}    obj       - An object.\r\n * @param {function}  callback  - A function handling each value. Arguments are value, property and index.\r\n */\n\nfunction each(obj, callback) {\n  keys(obj).some(function (key, index) {\n    return callback(obj[key], key, index);\n  });\n}\n/**\r\n * Return values of the given object as an array.\r\n * IE doesn't support Object.values.\r\n *\r\n * @param {Object} obj - An object.\r\n *\r\n * @return {Array} - An array containing all values of the given object.\r\n */\n\nfunction values(obj) {\n  return keys(obj).map(function (key) {\n    return obj[key];\n  });\n}\n/**\r\n * Check if the given subject is object or not.\r\n *\r\n * @param {*} subject - A subject to be verified.\r\n *\r\n * @return {boolean} - True if object, false otherwise.\r\n */\n\nfunction isObject(subject) {\n  return typeof subject === 'object';\n}\n/**\r\n * Merge two objects deeply.\r\n *\r\n * @param {Object} to   - An object where \"from\" is merged.\r\n * @param {Object} from - An object merged to \"to\".\r\n *\r\n * @return {Object} - A merged object.\r\n */\n\nfunction merge(_ref, from) {\n  var to = _extends({}, _ref);\n\n  each(from, function (value, key) {\n    if (isObject(value)) {\n      if (!isObject(to[key])) {\n        to[key] = {};\n      }\n\n      to[key] = merge(to[key], value);\n    } else {\n      to[key] = value;\n    }\n  });\n  return to;\n}\n/**\r\n * Assign all properties \"from\" to \"to\" object.\r\n *\r\n * @param {Object} to   - An object where properties are assigned.\r\n * @param {Object} from - An object whose properties are assigned to \"to\".\r\n *\r\n * @return {Object} - An assigned object.\r\n */\n\nfunction object_assign(to, from) {\n  keys(from).forEach(function (key) {\n    if (!to[key]) {\n      Object.defineProperty(to, key, Object.getOwnPropertyDescriptor(from, key));\n    }\n  });\n  return to;\n}\n// CONCATENATED MODULE: ./src/js/utils/utils.js\n/**\r\n * A package of some miscellaneous utility functions.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Convert the given value to array.\r\n *\r\n * @param {*} value - Any value.\r\n *\r\n * @return {*[]} - Array containing the given value.\r\n */\n\nfunction toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n/**\r\n * Check if the given value is between min and max.\r\n * Min will be returned when the value is less than min or max will do when greater than max.\r\n *\r\n * @param {number} value - A number to be checked.\r\n * @param {number} m1    - Minimum or maximum number.\r\n * @param {number} m2    - Maximum or minimum number.\r\n *\r\n * @return {number} - A value itself, min or max.\r\n */\n\nfunction between(value, m1, m2) {\n  return Math.min(Math.max(value, m1 > m2 ? m2 : m1), m1 > m2 ? m1 : m2);\n}\n/**\r\n * The sprintf method with minimum functionality.\r\n *\r\n * @param {string}       format       - The string format.\r\n * @param {string|Array} replacements - Replacements accepting multiple arguments.\r\n *\r\n * @returns {string} - Converted string.\r\n */\n\nfunction sprintf(format, replacements) {\n  var i = 0;\n  return format.replace(/%s/g, function () {\n    return toArray(replacements)[i++];\n  });\n}\n/**\r\n * Append px unit to the given subject if necessary.\r\n *\r\n * @param {number|string} value - A value that may not include an unit.\r\n *\r\n * @return {string} - If the value is string, return itself.\r\n *                    If number, do value + \"px\". An empty string, otherwise.\r\n */\n\nfunction unit(value) {\n  var type = typeof value;\n\n  if (type === 'number' && value > 0) {\n    return parseFloat(value) + 'px';\n  }\n\n  return type === 'string' ? value : '';\n}\n/**\r\n * Pad start with 0.\r\n *\r\n * @param {number} number - A number to be filled with 0.\r\n *\r\n * @return {string|number} - Padded number.\r\n */\n\nfunction pad(number) {\n  return number < 10 ? '0' + number : number;\n}\n/**\r\n * Convert the given value to pixel.\r\n *\r\n * @param {Element}       root  - Root element where a dummy div is appended.\r\n * @param {string|number} value - CSS value to be converted, such as 10rem.\r\n *\r\n * @return {number} - Pixel.\r\n */\n\nfunction toPixel(root, value) {\n  if (typeof value === 'string') {\n    var div = create('div', {});\n    applyStyle(div, {\n      position: 'absolute',\n      width: value\n    });\n    append(root, div);\n    value = div.clientWidth;\n    dom_remove(div);\n  }\n\n  return +value || 0;\n}\n// CONCATENATED MODULE: ./src/js/utils/dom.js\n/**\r\n * Some utility functions related with DOM.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Find the first element matching the given selector.\r\n * Be aware that all selectors after a space are ignored.\r\n *\r\n * @param {Element|Node}  elm       - An ancestor element.\r\n * @param {string}        selector  - DOMString.\r\n *\r\n * @return {Element|null} - A found element or null.\r\n */\n\nfunction find(elm, selector) {\n  return elm ? elm.querySelector(selector.split(' ')[0]) : null;\n}\n/**\r\n * Find a first child having the given tag or class name.\r\n *\r\n * @param {Element} parent         - A parent element.\r\n * @param {string}  tagOrClassName - A tag or class name.\r\n *\r\n * @return {Element|undefined} - A found element on success or undefined on failure.\r\n */\n\nfunction child(parent, tagOrClassName) {\n  return children(parent, tagOrClassName)[0];\n}\n/**\r\n * Return chile elements that matches the provided tag or class name.\r\n *\r\n * @param {Element} parent         - A parent element.\r\n * @param {string}  tagOrClassName - A tag or class name.\r\n *\r\n * @return {Element[]} - Found elements.\r\n */\n\nfunction children(parent, tagOrClassName) {\n  if (parent) {\n    return values(parent.children).filter(function (child) {\n      return hasClass(child, tagOrClassName.split(' ')[0]) || child.tagName === tagOrClassName;\n    });\n  }\n\n  return [];\n}\n/**\r\n * Create an element with some optional attributes.\r\n *\r\n * @param {string} tag   - A tag name.\r\n * @param {Object} attrs - An object any attribute pairs of name and value.\r\n *\r\n * @return {Element} - A created element.\r\n */\n\nfunction create(tag, attrs) {\n  var elm = document.createElement(tag);\n  each(attrs, function (value, key) {\n    return setAttribute(elm, key, value);\n  });\n  return elm;\n}\n/**\r\n * Convert HTML string to DOM node.\r\n *\r\n * @param {string} html - HTML string.\r\n *\r\n * @return {Node} - A created node.\r\n */\n\nfunction domify(html) {\n  var div = create('div', {});\n  div.innerHTML = html;\n  return div.firstChild;\n}\n/**\r\n * Remove a given element from a DOM tree.\r\n *\r\n * @param {Element|Element[]} elms - Element(s) to be removed.\r\n */\n\nfunction dom_remove(elms) {\n  toArray(elms).forEach(function (elm) {\n    if (elm) {\n      var parent = elm.parentElement;\n      parent && parent.removeChild(elm);\n    }\n  });\n}\n/**\r\n * Append a child to a given element.\r\n *\r\n * @param {Element} parent - A parent element.\r\n * @param {Element} child  - An element to be appended.\r\n */\n\nfunction append(parent, child) {\n  if (parent) {\n    parent.appendChild(child);\n  }\n}\n/**\r\n * Insert an element before the reference element.\r\n *\r\n * @param {Element|Node} ref - A reference element.\r\n * @param {Element}      elm - An element to be inserted.\r\n */\n\nfunction before(elm, ref) {\n  if (elm && ref) {\n    var parent = ref.parentElement;\n    parent && parent.insertBefore(elm, ref);\n  }\n}\n/**\r\n * Apply styles to the given element.\r\n *\r\n * @param {Element} elm     - An element where styles are applied.\r\n * @param {Object}  styles  - Object containing styles.\r\n */\n\nfunction applyStyle(elm, styles) {\n  if (elm) {\n    each(styles, function (value, prop) {\n      if (value !== null) {\n        elm.style[prop] = value;\n      }\n    });\n  }\n}\n/**\r\n * Add or remove classes to/from the element.\r\n * This function is for internal usage.\r\n *\r\n * @param {Element}         elm     - An element where classes are added.\r\n * @param {string|string[]} classes - Class names being added.\r\n * @param {boolean}         remove  - Whether to remove or add classes.\r\n */\n\nfunction addOrRemoveClasses(elm, classes, remove) {\n  if (elm) {\n    toArray(classes).forEach(function (name) {\n      if (name) {\n        elm.classList[remove ? 'remove' : 'add'](name);\n      }\n    });\n  }\n}\n/**\r\n * Add classes to the element.\r\n *\r\n * @param {Element}          elm     - An element where classes are added.\r\n * @param {string|string[]}  classes - Class names being added.\r\n */\n\n\nfunction addClass(elm, classes) {\n  addOrRemoveClasses(elm, classes, false);\n}\n/**\r\n * Remove a class from the element.\r\n *\r\n * @param {Element}         elm     - An element where classes are removed.\r\n * @param {string|string[]} classes - A class name being removed.\r\n */\n\nfunction removeClass(elm, classes) {\n  addOrRemoveClasses(elm, classes, true);\n}\n/**\r\n * Verify if the provided element has the class or not.\r\n *\r\n * @param {Element} elm       - An element.\r\n * @param {string}  className - A class name.\r\n *\r\n * @return {boolean} - True if the element has the class or false if not.\r\n */\n\nfunction hasClass(elm, className) {\n  return !!elm && elm.classList.contains(className);\n}\n/**\r\n * Set attribute to the given element.\r\n *\r\n * @param {Element}                 elm   - An element where an attribute is assigned.\r\n * @param {string}                  name  - Attribute name.\r\n * @param {string|number|boolean}   value - Attribute value.\r\n */\n\nfunction setAttribute(elm, name, value) {\n  if (elm) {\n    elm.setAttribute(name, value);\n  }\n}\n/**\r\n * Get attribute from the given element.\r\n *\r\n * @param {Element} elm  - An element where an attribute is assigned.\r\n * @param {string}  name - Attribute name.\r\n *\r\n * @return {string} - The value of the given attribute if available. An empty string if not.\r\n */\n\nfunction getAttribute(elm, name) {\n  return elm ? elm.getAttribute(name) : '';\n}\n/**\r\n * Remove attribute from the given element.\r\n *\r\n * @param {Element|Element[]} elms  - An element where an attribute is removed.\r\n * @param {string|string[]}      names - Attribute name.\r\n */\n\nfunction removeAttribute(elms, names) {\n  toArray(names).forEach(function (name) {\n    toArray(elms).forEach(function (elm) {\n      return elm && elm.removeAttribute(name);\n    });\n  });\n}\n/**\r\n * Return the Rect object of the provided object.\r\n *\r\n * @param {Element} elm - An element.\r\n *\r\n * @return {ClientRect|DOMRect} - A rect object.\r\n */\n\nfunction getRect(elm) {\n  return elm.getBoundingClientRect();\n}\n/**\r\n * Trigger the given callback after all images contained by the element are loaded.\r\n *\r\n * @param {Element}  elm      - Element that may contain images.\r\n * @param {Function} callback - Callback function fired right after all images are loaded.\r\n */\n\nfunction dom_loaded(elm, callback) {\n  var images = elm.querySelectorAll('img');\n  var length = images.length;\n\n  if (length) {\n    var count = 0;\n    each(images, function (img) {\n      img.onload = img.onerror = function () {\n        if (++count === length) {\n          callback();\n        }\n      };\n    });\n  } else {\n    // Trigger the callback immediately if there is no image.\n    callback();\n  }\n}\n// CONCATENATED MODULE: ./src/js/constants/types.js\n/**\r\n * Export slider types.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Normal slider.\r\n *\r\n * @type {string}\r\n */\nvar SLIDE = 'slide';\n/**\r\n * Loop after the last slide and before the first one.\r\n *\r\n * @type {string}\r\n */\n\nvar LOOP = 'loop';\n/**\r\n * The track doesn't move.\r\n *\r\n * @type {string}\r\n */\n\nvar FADE = 'fade';\n// CONCATENATED MODULE: ./src/js/transitions/slide/index.js\n/**\r\n * The component for general slide effect transition.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * The component for general slide effect transition.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ var transitions_slide = (function (Splide, Components) {\n  /**\r\n   * Hold the list element.\r\n   *\r\n   * @type {Element}\r\n   */\n  var list;\n  /**\r\n   * Hold the onEnd callback function.\r\n   *\r\n   * @type {function}\r\n   */\n\n  var endCallback;\n  return {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      list = Components.Elements.list;\n      Splide.on('transitionend', function (e) {\n        if (e.target === list && endCallback) {\n          endCallback();\n        }\n      }, list);\n    },\n\n    /**\r\n     * Start transition.\r\n     *\r\n     * @param {number}   destIndex - Destination slide index that might be clone's.\r\n     * @param {number}   newIndex  - New index.\r\n     * @param {number}   prevIndex - Previous index.\r\n     * @param {Object}   coord     - Destination coordinates.\r\n     * @param {function} done      - Callback function must be invoked when transition is completed.\r\n     */\n    start: function start(destIndex, newIndex, prevIndex, coord, done) {\n      var options = Splide.options;\n      var edgeIndex = Components.Controller.edgeIndex;\n      var speed = options.speed;\n      endCallback = done;\n\n      if (Splide.is(SLIDE)) {\n        if (prevIndex === 0 && newIndex >= edgeIndex || prevIndex >= edgeIndex && newIndex === 0) {\n          speed = options.rewindSpeed || speed;\n        }\n      }\n\n      applyStyle(list, {\n        transition: \"transform \" + speed + \"ms \" + options.easing,\n        transform: \"translate(\" + coord.x + \"px,\" + coord.y + \"px)\"\n      });\n    }\n  };\n});\n// CONCATENATED MODULE: ./src/js/transitions/fade/index.js\n/**\r\n * The component for fade transition.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * The component for fade transition.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ var fade = (function (Splide, Components) {\n  var Fade = {\n    /**\r\n     * Called when the component is mounted.\r\n     * Apply transition style to the first slide.\r\n     */\n    mount: function mount() {\n      apply(Splide.index);\n    },\n\n    /**\r\n     * Start transition.\r\n     *\r\n     * @param {number}    destIndex - Destination slide index that might be clone's.\r\n     * @param {number}    newIndex  - New index.\r\n     * @param {number}    prevIndex - Previous index.\r\n     * @param {Object}    coord     - Destination coordinates.\r\n     * @param {function}  done      - Callback function must be invoked when transition is completed.\r\n     */\n    start: function start(destIndex, newIndex, prevIndex, coord, done) {\n      var track = Components.Elements.track;\n      applyStyle(track, {\n        height: unit(track.clientHeight)\n      });\n      apply(newIndex);\n      setTimeout(function () {\n        done();\n        applyStyle(track, {\n          height: ''\n        });\n      });\n    }\n  };\n  /**\r\n   * Apply transition style to the slide specified by the given index.\r\n   *\r\n   * @param {number} index - A slide index.\r\n   */\n\n  function apply(index) {\n    var options = Splide.options;\n    applyStyle(Components.Elements.slides[index], {\n      transition: \"opacity \" + options.speed + \"ms \" + options.easing\n    });\n  }\n\n  return Fade;\n});\n// CONCATENATED MODULE: ./src/js/transitions/index.js\n/**\r\n * Export transition components.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n// CONCATENATED MODULE: ./src/js/core/composer.js\n/**\r\n * Provide a function for composing components.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * Compose components.\r\n *\r\n * @param {Splide}   Splide     - Splide instance.\r\n * @param {Object}   Components - Additional components.\r\n * @param {function} Transition - Change component for transition.\r\n *\r\n * @return {Object} - An object containing all components.\r\n */\n\nfunction compose(Splide, Components, Transition) {\n  var components = {};\n  each(Components, function (Component, name) {\n    components[name] = Component(Splide, components, name.toLowerCase());\n  });\n\n  if (!Transition) {\n    Transition = Splide.is(FADE) ? fade : transitions_slide;\n  }\n\n  components.Transition = Transition(Splide, components);\n  return components;\n}\n// CONCATENATED MODULE: ./src/js/utils/error.js\n/**\r\n * Utility functions for outputting logs.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Prefix of an error massage.\r\n *\r\n * @type {string}\r\n */\nvar MESSAGE_PREFIX = '[SPLIDE]';\n/**\r\n * Display an error message on the browser console.\r\n *\r\n * @param {string} message - An error message.\r\n */\n\nfunction error_error(message) {\n  console.error(MESSAGE_PREFIX + \" \" + message);\n}\n/**\r\n * Check existence of the given object and throw an error if it doesn't.\r\n *\r\n * @throws {Error}\r\n *\r\n * @param {*}      subject - A subject to be confirmed.\r\n * @param {string} message - An error message.\r\n */\n\nfunction exist(subject, message) {\n  if (!subject) {\n    throw new Error(message);\n  }\n}\n// CONCATENATED MODULE: ./src/js/constants/classes.js\n/**\r\n * Export class names.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * A root class name.\r\n *\r\n * @type {string}\r\n */\nvar ROOT = 'splide';\n/**\r\n * The definition table of all classes for elements.\r\n * They might be modified by options.\r\n *\r\n * @type {Object}\r\n */\n\nvar ELEMENT_CLASSES = {\n  root: ROOT,\n  slider: ROOT + \"__slider\",\n  track: ROOT + \"__track\",\n  list: ROOT + \"__list\",\n  slide: ROOT + \"__slide\",\n  container: ROOT + \"__slide__container\",\n  arrows: ROOT + \"__arrows\",\n  arrow: ROOT + \"__arrow\",\n  prev: ROOT + \"__arrow--prev\",\n  next: ROOT + \"__arrow--next\",\n  pagination: ROOT + \"__pagination\",\n  page: ROOT + \"__pagination__page\",\n  clone: ROOT + \"__slide--clone\",\n  progress: ROOT + \"__progress\",\n  bar: ROOT + \"__progress__bar\",\n  autoplay: ROOT + \"__autoplay\",\n  play: ROOT + \"__play\",\n  pause: ROOT + \"__pause\",\n  spinner: ROOT + \"__spinner\",\n  sr: ROOT + \"__sr\"\n};\n/**\r\n * Definitions of status classes.\r\n *\r\n * @type {Object}\r\n */\n\nvar STATUS_CLASSES = {\n  active: 'is-active',\n  visible: 'is-visible',\n  loading: 'is-loading'\n};\n// CONCATENATED MODULE: ./src/js/constants/i18n.js\n/**\r\n * Export i18n texts as object.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Texts for i18n.\r\n *\r\n * @type {Object}\r\n */\nvar I18N = {\n  prev: 'Previous slide',\n  next: 'Next slide',\n  first: 'Go to first slide',\n  last: 'Go to last slide',\n  slideX: 'Go to slide %s',\n  pageX: 'Go to page %s',\n  play: 'Start autoplay',\n  pause: 'Pause autoplay'\n};\n// CONCATENATED MODULE: ./src/js/constants/defaults.js\n/**\r\n * Export default options.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\nvar DEFAULTS = {\n  /**\r\n   * Determine a slider type.\r\n   * - 'slide': Regular slider.\r\n   * - 'loop' : Carousel slider.\r\n   * - 'fade' : Change slides with fade transition. perPage, drag options are ignored.\r\n   *\r\n   * @type {string}\r\n   */\n  type: 'slide',\n\n  /**\r\n   * Whether to rewind a slider before the first slide or after the last one.\r\n   * In \"loop\" mode, this option is ignored.\r\n   *\r\n   * @type {boolean}\r\n   */\n  rewind: false,\n\n  /**\r\n   * Transition speed in milliseconds.\r\n   *\r\n   * @type {number}\r\n   */\n  speed: 400,\n\n  /**\r\n   * Transition speed on rewind in milliseconds.\r\n   *\r\n   * @type {number}\r\n   */\n  rewindSpeed: 0,\n\n  /**\r\n   * Whether to prevent any actions while a slider is transitioning.\r\n   * If false, navigation, drag and swipe work while the slider is running.\r\n   * Even so, it will be forced to wait for transition in some cases in the loop mode to shift a slider.\r\n   *\r\n   * @type {boolean}\r\n   */\n  waitForTransition: true,\n\n  /**\r\n   * Define slider max width.\r\n   *\r\n   * @type {number}\r\n   */\n  width: 0,\n\n  /**\r\n   * Define slider height.\r\n   *\r\n   * @type {number}\r\n   */\n  height: 0,\n\n  /**\r\n   * Fix width of slides. CSS format is allowed such as 10em, 80% or 80vw.\r\n   * perPage number will be ignored when this option is falsy.\r\n   *\r\n   * @type {number|string}\r\n   */\n  fixedWidth: 0,\n\n  /**\r\n   * Fix height of slides. CSS format is allowed such as 10em, 80vh but % unit is not accepted.\r\n   * heightRatio option will be ignored when this option is falsy.\r\n   *\r\n   * @type {number|string}\r\n   */\n  fixedHeight: 0,\n\n  /**\r\n   * Determine height of slides by ratio to a slider width.\r\n   * This will be ignored when the fixedHeight is provided.\r\n   *\r\n   * @type {number}\r\n   */\n  heightRatio: 0,\n\n  /**\r\n   * If true, slide width will be determined by the element width itself.\r\n   * - perPage/perMove should be 1.\r\n   *\r\n   * @type {boolean}\r\n   */\n  autoWidth: false,\n\n  /**\r\n   * If true, slide height will be determined by the element width itself.\r\n   * - perPage/perMove should be 1.\r\n   *\r\n   * @type {boolean}\r\n   */\n  autoHeight: false,\n\n  /**\r\n   * Determine how many slides should be displayed per page.\r\n   *\r\n   * @type {number}\r\n   */\n  perPage: 1,\n\n  /**\r\n   * Determine how many slides should be moved when a slider goes to next or perv.\r\n   *\r\n   * @type {number}\r\n   */\n  perMove: 0,\n\n  /**\r\n   * Determine manually how many clones should be generated on the left and right side.\r\n   * The total number of clones will be twice of this number.\r\n   *\r\n   * @type {number}\r\n   */\n  clones: 0,\n\n  /**\r\n   * Start index.\r\n   *\r\n   * @type {number}\r\n   */\n  start: 0,\n\n  /**\r\n   * Determine which slide should be focused if there are multiple slides in a page.\r\n   * A string \"center\" is acceptable for centering slides.\r\n   *\r\n   * @type {boolean|number|string}\r\n   */\n  focus: false,\n\n  /**\r\n   * Gap between slides. CSS format is allowed such as 1em.\r\n   *\r\n   * @type {number|string}\r\n   */\n  gap: 0,\n\n  /**\r\n   * Set padding-left/right in horizontal mode or padding-top/bottom in vertical one.\r\n   * Give a single value to set a same size for both sides or\r\n   * do an object for different sizes.\r\n   * Also, CSS format is allowed such as 1em.\r\n   *\r\n   * @example\r\n   * - 10: Number\r\n   * - '1em': CSS format.\r\n   * - { left: 0, right: 20 }: Object for different sizes in horizontal mode.\r\n   * - { top: 0, bottom: 20 }: Object for different sizes in vertical mode.\r\n   *\r\n   * @type {number|string|Object}\r\n   */\n  padding: 0,\n\n  /**\r\n   * Whether to append arrows.\r\n   *\r\n   * @type {boolean}\r\n   */\n  arrows: true,\n\n  /**\r\n   * Change the arrow SVG path like 'm7.61 0.807-2.12...'.\r\n   *\r\n   * @type {string}\r\n   */\n  arrowPath: '',\n\n  /**\r\n   * Whether to append pagination(indicator dots) or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  pagination: true,\n\n  /**\r\n   * Activate autoplay.\r\n   *\r\n   * @type {boolean}\r\n   */\n  autoplay: false,\n\n  /**\r\n   * Autoplay interval in milliseconds.\r\n   *\r\n   * @type {number}\r\n   */\n  interval: 5000,\n\n  /**\r\n   * Whether to stop autoplay when a slider is hovered.\r\n   *\r\n   * @type {boolean}\r\n   */\n  pauseOnHover: true,\n\n  /**\r\n   * Whether to stop autoplay when a slider elements are focused.\r\n   * True is recommended for accessibility.\r\n   *\r\n   * @type {boolean}\r\n   */\n  pauseOnFocus: true,\n\n  /**\r\n   * Whether to reset progress of the autoplay timer when resumed.\r\n   *\r\n   * @type {boolean}\r\n   */\n  resetProgress: true,\n\n  /**\r\n   * Loading images lazily.\r\n   * Image src must be provided by a data-splide-lazy attribute.\r\n   *\r\n   * - false: Do nothing.\r\n   * - 'nearby': Only images around an active slide will be loaded.\r\n   * - 'sequential': All images will be sequentially loaded.\r\n   *\r\n   * @type {boolean|string}\r\n   */\n  lazyLoad: false,\n\n  /**\r\n   * This option works only when a lazyLoad option is \"nearby\".\r\n   * Determine how many pages(not slides) around an active slide should be loaded beforehand.\r\n   *\r\n   * @type {number}\r\n   */\n  preloadPages: 1,\n\n  /**\r\n   * Easing for CSS transition. For example, linear, ease or cubic-bezier().\r\n   *\r\n   * @type {string}\r\n   */\n  easing: 'cubic-bezier(.42,.65,.27,.99)',\n\n  /**\r\n   * Whether to enable keyboard shortcuts\r\n   * - true or 'global': Listen to keydown event of the document.\r\n   * - 'focused': Listen to the keydown event of the slider root element. tabindex=\"0\" will be added to the element.\r\n   * - false: Disable keyboard shortcuts.\r\n   *\r\n   * @type {boolean|string}\r\n   */\n  keyboard: 'global',\n\n  /**\r\n   * Whether to allow mouse drag and touch swipe.\r\n   *\r\n   * @type {boolean}\r\n   */\n  drag: true,\n\n  /**\r\n   * The angle threshold for drag.\r\n   * The slider starts moving only when the drag angle is less than this threshold.\r\n   *\r\n   * @type {number}\r\n   */\n  dragAngleThreshold: 30,\n\n  /**\r\n   * Distance threshold for determining if the action is \"flick\" or \"swipe\".\r\n   * When a drag distance is over this value, the action will be treated as \"swipe\", not \"flick\".\r\n   *\r\n   * @type {number}\r\n   */\n  swipeDistanceThreshold: 150,\n\n  /**\r\n   * Velocity threshold for determining if the action is \"flick\" or \"swipe\".\r\n   * Around 0.5 is recommended.\r\n   *\r\n   * @type {number}\r\n   */\n  flickVelocityThreshold: .6,\n\n  /**\r\n   * Determine power of flick. The larger number this is, the farther a slider runs by flick.\r\n   * Around 500 is recommended.\r\n   *\r\n   * @type {number}\r\n   */\n  flickPower: 600,\n\n  /**\r\n   * Limit a number of pages to move by flick.\r\n   *\r\n   * @type {number}\r\n   */\n  flickMaxPages: 1,\n\n  /**\r\n   * Slider direction.\r\n   * - 'ltr': Left to right.\r\n   * - 'rtl': Right to left.\r\n   * - 'ttb': Top to bottom.\r\n   *\r\n   * @type {string}\r\n   */\n  direction: 'ltr',\n\n  /**\r\n   * Set img src to background-image of its parent element.\r\n   * Images with various sizes can be displayed as same dimension without cropping work.\r\n   * fixedHeight or heightRatio is required.\r\n   *\r\n   * @type {boolean}\r\n   */\n  cover: false,\n\n  /**\r\n   * Whether to enable accessibility(aria and screen reader texts) or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  accessibility: true,\n\n  /**\r\n   * Whether to add tabindex=\"0\" to visible slides or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  slideFocus: true,\n\n  /**\r\n   * Determine if a slider is navigation for another.\r\n   * Use \"sync\" API to synchronize two sliders.\r\n   *\r\n   * @type {boolean}\r\n   */\n  isNavigation: false,\n\n  /**\r\n   * Whether to trim spaces before the fist slide or after the last one when \"focus\" is not 0.\r\n   *\r\n   * @type {boolean}\r\n   */\n  trimSpace: true,\n\n  /**\r\n   * The \"is-active\" class is added after transition as default.\r\n   * If true, it will be added before move.\r\n   *\r\n   * @type {boolean}\r\n   */\n  updateOnMove: false,\n\n  /**\r\n   * Throttle duration in milliseconds for the resize event.\r\n   *\r\n   * @type {number}\r\n   */\n  throttle: 100,\n\n  /**\r\n   * Whether to destroy a slider or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  destroy: false,\n\n  /**\r\n   * Options for specific breakpoints.\r\n   *\r\n   * @example\r\n   * {\r\n   *   1000: {\r\n   *     perPage: 3,\r\n   *     gap: 20\r\n   *   },\r\n   *   600: {\r\n   *     perPage: 1,\r\n   *     gap: 5,\r\n   *   }\r\n   * }\r\n   *\r\n   * @type {boolean|Object}\r\n   */\n  breakpoints: false,\n\n  /**\r\n   * Collection of class names.\r\n   *\r\n   * @see ./classes.js\r\n   *\r\n   * @type {Object}\r\n   */\n  classes: ELEMENT_CLASSES,\n\n  /**\r\n   * Collection of i18n texts.\r\n   *\r\n   * @see ./i18n.js\r\n   *\r\n   * @type {Object}\r\n   */\n  i18n: I18N\n};\n// CONCATENATED MODULE: ./src/js/constants/states.js\n/**\r\n * Export state constants.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Splide has been just created.\r\n *\r\n * @type {number}\r\n */\nvar CREATED = 1;\n/**\r\n * All components have been mounted and initialized.\r\n *\r\n * @type {number}\r\n */\n\nvar MOUNTED = 2;\n/**\r\n * Splide is ready for transition.\r\n *\r\n * @type {number}\r\n */\n\nvar IDLE = 3;\n/**\r\n * Splide is moving.\r\n *\r\n * @type {number}\r\n */\n\nvar MOVING = 4;\n/**\r\n * Splide is moving.\r\n *\r\n * @type {number}\r\n */\n\nvar DESTROYED = 5;\n// CONCATENATED MODULE: ./src/js/splide.js\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n * The main class for applying Splide to an element.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n\n\n\n/**\r\n * The main class for applying Splide to an element,\r\n * providing some APIs to control the behavior.\r\n */\n\nvar splide_Splide = /*#__PURE__*/function () {\n  /**\r\n   * Splide constructor.\r\n   *\r\n   * @throws {Error} When the given root element or selector is invalid.\r\n   *\r\n   * @param {Element|string}  root       - A selector for a root element or an element itself.\r\n   * @param {Object}          options    - Optional. Options to change default behaviour.\r\n   * @param {Object}          Components - Optional. Components.\r\n   */\n  function Splide(root, options, Components) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (Components === void 0) {\n      Components = {};\n    }\n\n    this.root = root instanceof Element ? root : document.querySelector(root);\n    exist(this.root, 'An invalid element/selector was given.');\n    this.Components = null;\n    this.Event = core_event();\n    this.State = state(CREATED);\n    this.STATES = states_namespaceObject;\n    this._o = merge(DEFAULTS, options);\n    this._i = 0;\n    this._c = Components;\n    this._e = {}; // Extensions\n\n    this._t = null; // Transition\n  }\n  /**\r\n   * Compose and mount components.\r\n   *\r\n   * @param {Object}   Extensions - Optional. Additional components.\r\n   * @param {function} Transition - Optional. Set a custom transition component.\r\n   *\r\n   * @return {Splide|undefined} - This instance or undefined if an exception occurred.\r\n   */\n\n\n  var _proto = Splide.prototype;\n\n  _proto.mount = function mount(Extensions, Transition) {\n    var _this = this;\n\n    if (Extensions === void 0) {\n      Extensions = this._e;\n    }\n\n    if (Transition === void 0) {\n      Transition = this._t;\n    }\n\n    // Reset the state.\n    this.State.set(CREATED);\n    this._e = Extensions;\n    this._t = Transition;\n    this.Components = compose(this, merge(this._c, Extensions), Transition);\n\n    try {\n      each(this.Components, function (component, key) {\n        var required = component.required;\n\n        if (required === undefined || required) {\n          component.mount && component.mount();\n        } else {\n          delete _this.Components[key];\n        }\n      });\n    } catch (e) {\n      error_error(e.message);\n      return;\n    }\n\n    var State = this.State;\n    State.set(MOUNTED);\n    each(this.Components, function (component) {\n      component.mounted && component.mounted();\n    });\n    this.emit('mounted');\n    State.set(IDLE);\n    this.emit('ready');\n    applyStyle(this.root, {\n      visibility: 'visible'\n    });\n    this.on('move drag', function () {\n      return State.set(MOVING);\n    }).on('moved dragged', function () {\n      return State.set(IDLE);\n    });\n    return this;\n  }\n  /**\r\n   * Set sync target.\r\n   *\r\n   * @param {Splide} splide - A Splide instance.\r\n   *\r\n   * @return {Splide} - This instance.\r\n   */\n  ;\n\n  _proto.sync = function sync(splide) {\n    this.sibling = splide;\n    return this;\n  }\n  /**\r\n   * Register callback fired on the given event(s).\r\n   *\r\n   * @param {string}   events  - An event name. Use space to separate multiple events.\r\n   *                             Also, namespace is accepted by dot, such as 'resize.{namespace}'.\r\n   * @param {function} handler - A callback function.\r\n   * @param {Element}  elm     - Optional. Native event will be listened to when this arg is provided.\r\n   * @param {Object}   options - Optional. Options for addEventListener.\r\n   *\r\n   * @return {Splide} - This instance.\r\n   */\n  ;\n\n  _proto.on = function on(events, handler, elm, options) {\n    if (elm === void 0) {\n      elm = null;\n    }\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.Event.on(events, handler, elm, options);\n    return this;\n  }\n  /**\r\n   * Unsubscribe the given event.\r\n   *\r\n   * @param {string}  events - A event name.\r\n   * @param {Element} elm    - Optional. removeEventListener() will be called when this arg is provided.\r\n   *\r\n   * @return {Splide} - This instance.\r\n   */\n  ;\n\n  _proto.off = function off(events, elm) {\n    if (elm === void 0) {\n      elm = null;\n    }\n\n    this.Event.off(events, elm);\n    return this;\n  }\n  /**\r\n   * Emit an event.\r\n   *\r\n   * @param {string} event - An event name.\r\n   * @param {*}      args  - Any number of arguments passed to handlers.\r\n   */\n  ;\n\n  _proto.emit = function emit(event) {\n    var _this$Event;\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    (_this$Event = this.Event).emit.apply(_this$Event, [event].concat(args));\n\n    return this;\n  }\n  /**\r\n   * Go to the slide specified by the given control.\r\n   *\r\n   * @param {string|number} control - A control pattern.\r\n   * @param {boolean}       wait    - Optional. Whether to wait for transition.\r\n   */\n  ;\n\n  _proto.go = function go(control, wait) {\n    if (wait === void 0) {\n      wait = this.options.waitForTransition;\n    }\n\n    if (this.State.is(IDLE) || this.State.is(MOVING) && !wait) {\n      this.Components.Controller.go(control, false);\n    }\n\n    return this;\n  }\n  /**\r\n   * Verify whether the slider type is the given one or not.\r\n   *\r\n   * @param {string} type - A slider type.\r\n   *\r\n   * @return {boolean} - True if the slider type is the provided type or false if not.\r\n   */\n  ;\n\n  _proto.is = function is(type) {\n    return type === this._o.type;\n  }\n  /**\r\n   * Insert a slide.\r\n   *\r\n   * @param {Element|string} slide - A slide element to be added.\r\n   * @param {number}         index - A slide will be added at the position.\r\n   */\n  ;\n\n  _proto.add = function add(slide, index) {\n    if (index === void 0) {\n      index = -1;\n    }\n\n    this.Components.Elements.add(slide, index, this.refresh.bind(this));\n    return this;\n  }\n  /**\r\n   * Remove the slide designated by the index.\r\n   *\r\n   * @param {number} index - A slide index.\r\n   */\n  ;\n\n  _proto.remove = function remove(index) {\n    this.Components.Elements.remove(index);\n    this.refresh();\n    return this;\n  }\n  /**\r\n   * Destroy all Slide objects and clones and recreate them again.\r\n   */\n  ;\n\n  _proto.refresh = function refresh() {\n    this.emit('refresh').emit('resize');\n    return this;\n  }\n  /**\r\n   * Destroy the Splide.\r\n   * \"Completely\" boolean is mainly for breakpoints.\r\n   *\r\n   * @param {boolean} completely - Destroy completely.\r\n   */\n  ;\n\n  _proto.destroy = function destroy(completely) {\n    var _this2 = this;\n\n    if (completely === void 0) {\n      completely = true;\n    }\n\n    // Postpone destroy because it should be done after mount.\n    if (this.State.is(CREATED)) {\n      this.on('ready', function () {\n        return _this2.destroy(completely);\n      });\n      return;\n    }\n\n    values(this.Components).reverse().forEach(function (component) {\n      component.destroy && component.destroy(completely);\n    });\n    this.emit('destroy', completely); // Destroy all event handlers, including ones for native events.\n\n    this.Event.destroy();\n    this.State.set(DESTROYED);\n    return this;\n  }\n  /**\r\n   * Return the current slide index.\r\n   *\r\n   * @return {number} - The current slide index.\r\n   // */\n  ;\n\n  _createClass(Splide, [{\n    key: \"index\",\n    get: function get() {\n      return this._i;\n    }\n    /**\r\n     * Set the current slide index.\r\n     *\r\n     * @param {number|string} index - A new index.\r\n     */\n    ,\n    set: function set(index) {\n      this._i = parseInt(index);\n    }\n    /**\r\n     * Return length of slides.\r\n     * This is an alias of Elements.length.\r\n     *\r\n     * @return {number} - A number of slides.\r\n     */\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.Components.Elements.length;\n    }\n    /**\r\n     * Return options.\r\n     *\r\n     * @return {Object} - Options object.\r\n     */\n\n  }, {\n    key: \"options\",\n    get: function get() {\n      return this._o;\n    }\n    /**\r\n     * Set options with merging the given object to the current one.\r\n     *\r\n     * @param {Object} options - New options.\r\n     */\n    ,\n    set: function set(options) {\n      var created = this.State.is(CREATED);\n\n      if (!created) {\n        this.emit('update');\n      }\n\n      this._o = merge(this._o, options);\n\n      if (!created) {\n        this.emit('updated', this._o);\n      }\n    }\n    /**\r\n     * Return the class list.\r\n     * This is an alias of Splide.options.classList.\r\n     *\r\n     * @return {Object} - An object containing all class list.\r\n     */\n\n  }, {\n    key: \"classes\",\n    get: function get() {\n      return this._o.classes;\n    }\n    /**\r\n     * Return the i18n strings.\r\n     * This is an alias of Splide.options.i18n.\r\n     *\r\n     * @return {Object} - An object containing all i18n strings.\r\n     */\n\n  }, {\n    key: \"i18n\",\n    get: function get() {\n      return this._o.i18n;\n    }\n  }]);\n\n  return Splide;\n}();\n\n\n// CONCATENATED MODULE: ./src/js/components/options/index.js\n/**\r\n * The component for initializing options.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The component for initializing options.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ var components_options = (function (Splide) {\n  /**\r\n   * Retrieve options from the data attribute.\r\n   * Note that IE10 doesn't support dataset property.\r\n   *\r\n   * @type {string}\r\n   */\n  var options = getAttribute(Splide.root, 'data-splide');\n\n  if (options) {\n    try {\n      Splide.options = JSON.parse(options);\n    } catch (e) {\n      error_error(e.message);\n    }\n  }\n\n  return {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      if (Splide.State.is(CREATED)) {\n        Splide.index = Splide.options.start;\n      }\n    }\n  };\n});\n// CONCATENATED MODULE: ./src/js/constants/directions.js\n/**\r\n * Export layout modes.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Enumerate slides from left to right.\r\n *\r\n * @type {string}\r\n */\nvar LTR = 'ltr';\n/**\r\n * Enumerate slides from right to left.\r\n *\r\n * @type {string}\r\n */\n\nvar RTL = 'rtl';\n/**\r\n * Enumerate slides in a col.\r\n *\r\n * @type {string}\r\n */\n\nvar TTB = 'ttb';\n// CONCATENATED MODULE: ./src/js/components/elements/slide.js\n/**\r\n * The sub component for handling each slide.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n\n/**\r\n * Events for restoring original styles.\r\n *\r\n * @type {string}\r\n */\n\nvar STYLE_RESTORE_EVENTS = 'update.slide';\n/**\r\n * The sub component for handling each slide.\r\n *\r\n * @param {Splide}  Splide    - A Splide instance.\r\n * @param {number}  index     - An unique slide index.\r\n * @param {number}  realIndex - Clones should pass a real slide index.\r\n * @param {Element} slide     - A slide element.\r\n *\r\n * @return {Object} - The sub component object.\r\n */\n\n/* harmony default export */ var elements_slide = (function (Splide, index, realIndex, slide) {\n  /**\r\n   * Whether to update \"is-active\" class before or after transition.\r\n   *\r\n   * @type {boolean}\r\n   */\n  var updateOnMove = Splide.options.updateOnMove;\n  /**\r\n   * Events when the slide status is updated.\r\n   * Append a namespace to remove listeners later.\r\n   *\r\n   * @type {string}\r\n   */\n\n  var STATUS_UPDATE_EVENTS = 'ready.slide updated.slide resize.slide moved.slide' + (updateOnMove ? ' move.slide' : '');\n  /**\r\n   * Slide sub component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Slide = {\n    /**\r\n     * Slide element.\r\n     *\r\n     * @type {Element}\r\n     */\n    slide: slide,\n\n    /**\r\n     * Slide index.\r\n     *\r\n     * @type {number}\r\n     */\n    index: index,\n\n    /**\r\n     * Real index for clones.\r\n     *\r\n     * @type {number}\r\n     */\n    realIndex: realIndex,\n\n    /**\r\n     * Container element if available.\r\n     *\r\n     * @type {Element|undefined}\r\n     */\n    container: child(slide, Splide.classes.container),\n\n    /**\r\n     * Whether this is a cloned slide or not.\r\n     *\r\n     * @type {boolean}\r\n     */\n    isClone: realIndex > -1,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      var _this = this;\n\n      if (!this.isClone) {\n        slide.id = Splide.root.id + \"-slide\" + pad(index + 1);\n      }\n\n      Splide.on(STATUS_UPDATE_EVENTS, function () {\n        return _this.update();\n      }).on(STYLE_RESTORE_EVENTS, restoreStyles).on('click', function () {\n        return Splide.emit('click', _this);\n      }, slide);\n      /*\r\n       * Add \"is-active\" class to a clone element temporarily\r\n       * and it will be removed on \"moved\" event.\r\n       */\n\n      if (updateOnMove) {\n        Splide.on('move.slide', function (newIndex) {\n          if (newIndex === realIndex) {\n            _update(true, false);\n          }\n        });\n      } // Make sure the slide is shown.\n\n\n      applyStyle(slide, {\n        display: ''\n      }); // Hold the original styles.\n\n      this.styles = getAttribute(slide, 'style') || '';\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      Splide.off(STATUS_UPDATE_EVENTS).off(STYLE_RESTORE_EVENTS).off('click', slide);\n      removeClass(slide, values(STATUS_CLASSES));\n      restoreStyles();\n      removeAttribute(this.container, 'style');\n    },\n\n    /**\r\n     * Update active and visible status.\r\n     */\n    update: function update() {\n      _update(this.isActive(), false);\n\n      _update(this.isVisible(), true);\n    },\n\n    /**\r\n     * Check whether this slide is active or not.\r\n     *\r\n     * @return {boolean} - True if the slide is active or false if not.\r\n     */\n    isActive: function isActive() {\n      return Splide.index === index;\n    },\n\n    /**\r\n     * Check whether this slide is visible in the viewport or not.\r\n     *\r\n     * @return {boolean} - True if the slide is visible or false if not.\r\n     */\n    isVisible: function isVisible() {\n      var active = this.isActive();\n\n      if (Splide.is(FADE) || active) {\n        return active;\n      }\n\n      var trackRect = getRect(Splide.Components.Elements.track);\n      var slideRect = getRect(slide);\n\n      if (Splide.options.direction === TTB) {\n        return trackRect.top <= slideRect.top && slideRect.bottom <= trackRect.bottom;\n      }\n\n      return trackRect.left <= slideRect.left && slideRect.right <= trackRect.right;\n    },\n\n    /**\r\n     * Calculate how far this slide is from another slide and\r\n     * return true if the distance is within the given number.\r\n     *\r\n     * @param {number} from   - Index of a target slide.\r\n     * @param {number} within - True if the slide is within this number.\r\n     *\r\n     * @return {boolean} - True if the slide is within the number or false otherwise.\r\n     */\n    isWithin: function isWithin(from, within) {\n      var diff = Math.abs(from - index);\n\n      if (!Splide.is(SLIDE) && !this.isClone) {\n        diff = Math.min(diff, Splide.length - diff);\n      }\n\n      return diff < within;\n    }\n  };\n  /**\r\n   * Update classes for activity or visibility.\r\n   *\r\n   * @param {boolean} active        - Is active/visible or not.\r\n   * @param {boolean} forVisibility - Toggle classes for activity or visibility.\r\n   */\n\n  function _update(active, forVisibility) {\n    var type = forVisibility ? 'visible' : 'active';\n    var className = STATUS_CLASSES[type];\n\n    if (active) {\n      addClass(slide, className);\n      Splide.emit(\"\" + type, Slide);\n    } else {\n      if (hasClass(slide, className)) {\n        removeClass(slide, className);\n        Splide.emit(\"\" + (forVisibility ? 'hidden' : 'inactive'), Slide);\n      }\n    }\n  }\n  /**\r\n   * Restore the original styles.\r\n   */\n\n\n  function restoreStyles() {\n    setAttribute(slide, 'style', Slide.styles);\n  }\n\n  return Slide;\n});\n// CONCATENATED MODULE: ./src/js/components/elements/index.js\n/**\r\n * The component for main elements.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n/**\r\n * The property name for UID stored in a window object.\r\n *\r\n * @type {string}\r\n */\n\nvar UID_NAME = 'uid';\n/**\r\n * The component for main elements.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ var components_elements = (function (Splide, Components) {\n  /**\r\n   * Hold the root element.\r\n   *\r\n   * @type {Element}\r\n   */\n  var root = Splide.root;\n  /**\r\n   * Hold the class list.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var classes = Splide.classes;\n  /**\r\n   * Store Slide objects.\r\n   *\r\n   * @type {Array}\r\n   */\n\n  var Slides = [];\n  /*\r\n   * Assign unique ID to the root element if it doesn't have the one.\r\n   * Note that IE doesn't support padStart() to fill the uid by 0.\r\n   */\n\n  if (!root.id) {\n    window.splide = window.splide || {};\n    var uid = window.splide[UID_NAME] || 0;\n    window.splide[UID_NAME] = ++uid;\n    root.id = \"splide\" + pad(uid);\n  }\n  /**\r\n   * Elements component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n\n  var Elements = {\n    /**\r\n     * Called when the component is mounted.\r\n     * Collect main elements and store them as member properties.\r\n     */\n    mount: function mount() {\n      var _this = this;\n\n      this.init();\n      Splide.on('refresh', function () {\n        _this.destroy();\n\n        _this.init();\n      }).on('updated', function () {\n        removeClass(root, getClasses());\n        addClass(root, getClasses());\n      });\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      Slides.forEach(function (Slide) {\n        Slide.destroy();\n      });\n      Slides = [];\n      removeClass(root, getClasses());\n    },\n\n    /**\r\n     * Initialization.\r\n     */\n    init: function init() {\n      var _this2 = this;\n\n      collect();\n      addClass(root, getClasses());\n      this.slides.forEach(function (slide, index) {\n        _this2.register(slide, index, -1);\n      });\n    },\n\n    /**\r\n     * Register a slide to create a Slide object and handle its behavior.\r\n     *\r\n     * @param {Element} slide     - A slide element.\r\n     * @param {number}  index     - A unique index. This can be negative.\r\n     * @param {number}  realIndex - A real index for clones. Set -1 for real slides.\r\n     */\n    register: function register(slide, index, realIndex) {\n      var SlideObject = elements_slide(Splide, index, realIndex, slide);\n      SlideObject.mount();\n      Slides.push(SlideObject);\n    },\n\n    /**\r\n     * Return the Slide object designated by the index.\r\n     * Note that \"find\" is not supported by IE.\r\n     *\r\n     * @return {Object|undefined} - A Slide object if available. Undefined if not.\r\n     */\n    getSlide: function getSlide(index) {\n      return Slides.filter(function (Slide) {\n        return Slide.index === index;\n      })[0];\n    },\n\n    /**\r\n     * Return all Slide objects.\r\n     *\r\n     * @param {boolean} includeClones - Whether to include cloned slides or not.\r\n     *\r\n     * @return {Object[]} - Slide objects.\r\n     */\n    getSlides: function getSlides(includeClones) {\n      return includeClones ? Slides : Slides.filter(function (Slide) {\n        return !Slide.isClone;\n      });\n    },\n\n    /**\r\n     * Return Slide objects belonging to the given page.\r\n     *\r\n     * @param {number} page - A page number.\r\n     *\r\n     * @return {Object[]} - An array containing Slide objects.\r\n     */\n    getSlidesByPage: function getSlidesByPage(page) {\n      var idx = Components.Controller.toIndex(page);\n      var options = Splide.options;\n      var max = options.focus !== false ? 1 : options.perPage;\n      return Slides.filter(function (_ref) {\n        var index = _ref.index;\n        return idx <= index && index < idx + max;\n      });\n    },\n\n    /**\r\n     * Insert a slide to a slider.\r\n     * Need to refresh Splide after adding a slide.\r\n     *\r\n     * @param {Node|string} slide    - A slide element to be added.\r\n     * @param {number}      index    - A slide will be added at the position.\r\n     * @param {Function}    callback - Called right after the slide is added to the DOM tree.\r\n     */\n    add: function add(slide, index, callback) {\n      if (typeof slide === 'string') {\n        slide = domify(slide);\n      }\n\n      if (slide instanceof Element) {\n        var ref = this.slides[index]; // This will be removed in mount() of a Slide component.\n\n        applyStyle(slide, {\n          display: 'none'\n        });\n\n        if (ref) {\n          before(slide, ref);\n          this.slides.splice(index, 0, slide);\n        } else {\n          append(this.list, slide);\n          this.slides.push(slide);\n        }\n\n        dom_loaded(slide, function () {\n          callback && callback(slide);\n        });\n      }\n    },\n\n    /**\r\n     * Remove a slide from a slider.\r\n     * Need to refresh Splide after removing a slide.\r\n     *\r\n     * @param index - Slide index.\r\n     */\n    remove: function remove(index) {\n      dom_remove(this.slides.splice(index, 1)[0]);\n    },\n\n    /**\r\n     * Trigger the provided callback for each Slide object.\r\n     *\r\n     * @param {Function} callback - A callback function. The first argument will be the Slide object.\r\n     */\n    each: function each(callback) {\n      Slides.forEach(callback);\n    },\n\n    /**\r\n     * Return slides length without clones.\r\n     *\r\n     * @return {number} - Slide length.\r\n     */\n    get length() {\n      return this.slides.length;\n    },\n\n    /**\r\n     * Return \"SlideObjects\" length including clones.\r\n     *\r\n     * @return {number} - Slide length including clones.\r\n     */\n    get total() {\n      return Slides.length;\n    }\n\n  };\n  /**\r\n   * Collect elements.\r\n   */\n\n  function collect() {\n    Elements.slider = child(root, classes.slider);\n    Elements.track = find(root, \".\" + classes.track);\n    Elements.list = child(Elements.track, classes.list);\n    exist(Elements.track && Elements.list, 'Track or list was not found.');\n    Elements.slides = children(Elements.list, classes.slide);\n    var arrows = findParts(classes.arrows);\n    Elements.arrows = {\n      prev: find(arrows, \".\" + classes.prev),\n      next: find(arrows, \".\" + classes.next)\n    };\n    var autoplay = findParts(classes.autoplay);\n    Elements.bar = find(findParts(classes.progress), \".\" + classes.bar);\n    Elements.play = find(autoplay, \".\" + classes.play);\n    Elements.pause = find(autoplay, \".\" + classes.pause);\n    Elements.track.id = Elements.track.id || root.id + \"-track\";\n    Elements.list.id = Elements.list.id || root.id + \"-list\";\n  }\n  /**\r\n   * Return class names for the root element.\r\n   */\n\n\n  function getClasses() {\n    var rootClass = classes.root;\n    var options = Splide.options;\n    return [rootClass + \"--\" + options.type, rootClass + \"--\" + options.direction, options.drag ? rootClass + \"--draggable\" : '', options.isNavigation ? rootClass + \"--nav\" : '', STATUS_CLASSES.active];\n  }\n  /**\r\n   * Find parts only from children of the root or track.\r\n   *\r\n   * @return {Element} - A found element or undefined.\r\n   */\n\n\n  function findParts(className) {\n    return child(root, className) || child(Elements.slider, className);\n  }\n\n  return Elements;\n});\n// CONCATENATED MODULE: ./src/js/components/controller/index.js\n/**\r\n * The component for controlling the track.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\nvar floor = Math.floor;\n/**\r\n * The component for controlling the track.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ var controller = (function (Splide, Components) {\n  /**\r\n   * Store current options.\r\n   *\r\n   * @type {Object}\r\n   */\n  var options;\n  /**\r\n   * True if the slide is LOOP mode.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isLoop;\n  /**\r\n   * Controller component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Controller = {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      options = Splide.options;\n      isLoop = Splide.is(LOOP);\n      bind();\n    },\n\n    /**\r\n     * Make track run by the given control.\r\n     * - \"+{i}\" : Increment the slide index by i.\r\n     * - \"-{i}\" : Decrement the slide index by i.\r\n     * - \"{i}\"  : Go to the slide whose index is i.\r\n     * - \">\"    : Go to next page.\r\n     * - \"<\"    : Go to prev page.\r\n     * - \">{i}\" : Go to page i.\r\n     *\r\n     * @param {string|number} control  - A control pattern.\r\n     * @param {boolean}       silently - Go to the destination without event emission.\r\n     */\n    go: function go(control, silently) {\n      var destIndex = this.trim(this.parse(control));\n      Components.Track.go(destIndex, this.rewind(destIndex), silently);\n    },\n\n    /**\r\n     * Parse the given control and return the destination index for the track.\r\n     *\r\n     * @param {string} control - A control target pattern.\r\n     *\r\n     * @return {number} - A parsed target.\r\n     */\n    parse: function parse(control) {\n      var index = Splide.index;\n      var matches = String(control).match(/([+\\-<>]+)(\\d+)?/);\n      var indicator = matches ? matches[1] : '';\n      var number = matches ? parseInt(matches[2]) : 0;\n\n      switch (indicator) {\n        case '+':\n          index += number || 1;\n          break;\n\n        case '-':\n          index -= number || 1;\n          break;\n\n        case '>':\n        case '<':\n          index = parsePage(number, index, indicator === '<');\n          break;\n\n        default:\n          index = parseInt(control);\n      }\n\n      return index;\n    },\n\n    /**\r\n     * Compute index from the given page number.\r\n     *\r\n     * @param {number} page - Page number.\r\n     *\r\n     * @return {number} - A computed page number.\r\n     */\n    toIndex: function toIndex(page) {\n      if (hasFocus()) {\n        return page;\n      }\n\n      var length = Splide.length;\n      var perPage = options.perPage;\n      var index = page * perPage;\n      index = index - (this.pageLength * perPage - length) * floor(index / length); // Adjustment for the last page.\n\n      if (length - perPage <= index && index < length) {\n        index = length - perPage;\n      }\n\n      return index;\n    },\n\n    /**\r\n     * Compute page number from the given slide index.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {number} - A computed page number.\r\n     */\n    toPage: function toPage(index) {\n      if (hasFocus()) {\n        return index;\n      }\n\n      var length = Splide.length;\n      var perPage = options.perPage; // Make the last \"perPage\" number of slides belong to the last page.\n\n      if (length - perPage <= index && index < length) {\n        return floor((length - 1) / perPage);\n      }\n\n      return floor(index / perPage);\n    },\n\n    /**\r\n     * Trim the given index according to the current mode.\r\n     * Index being returned could be less than 0 or greater than the length in Loop mode.\r\n     *\r\n     * @param {number} index - An index being trimmed.\r\n     *\r\n     * @return {number} - A trimmed index.\r\n     */\n    trim: function trim(index) {\n      if (!isLoop) {\n        index = options.rewind ? this.rewind(index) : between(index, 0, this.edgeIndex);\n      }\n\n      return index;\n    },\n\n    /**\r\n     * Rewind the given index if it's out of range.\r\n     *\r\n     * @param {number} index - An index.\r\n     *\r\n     * @return {number} - A rewound index.\r\n     */\n    rewind: function rewind(index) {\n      var edge = this.edgeIndex;\n\n      if (isLoop) {\n        while (index > edge) {\n          index -= edge + 1;\n        }\n\n        while (index < 0) {\n          index += edge + 1;\n        }\n      } else {\n        if (index > edge) {\n          index = 0;\n        } else if (index < 0) {\n          index = edge;\n        }\n      }\n\n      return index;\n    },\n\n    /**\r\n     * Check if the direction is \"rtl\" or not.\r\n     *\r\n     * @return {boolean} - True if \"rtl\" or false if not.\r\n     */\n    isRtl: function isRtl() {\n      return options.direction === RTL;\n    },\n\n    /**\r\n     * Return the page length.\r\n     *\r\n     * @return {number} - Max page number.\r\n     */\n    get pageLength() {\n      var length = Splide.length;\n      return hasFocus() ? length : Math.ceil(length / options.perPage);\n    },\n\n    /**\r\n     * Return the edge index.\r\n     *\r\n     * @return {number} - Edge index.\r\n     */\n    get edgeIndex() {\n      var length = Splide.length;\n\n      if (!length) {\n        return 0;\n      }\n\n      if (hasFocus() || options.isNavigation || isLoop) {\n        return length - 1;\n      }\n\n      return length - options.perPage;\n    },\n\n    /**\r\n     * Return the index of the previous slide.\r\n     *\r\n     * @return {number} - The index of the previous slide if available. -1 otherwise.\r\n     */\n    get prevIndex() {\n      var prev = Splide.index - 1;\n\n      if (isLoop || options.rewind) {\n        prev = this.rewind(prev);\n      }\n\n      return prev > -1 ? prev : -1;\n    },\n\n    /**\r\n     * Return the index of the next slide.\r\n     *\r\n     * @return {number} - The index of the next slide if available. -1 otherwise.\r\n     */\n    get nextIndex() {\n      var next = Splide.index + 1;\n\n      if (isLoop || options.rewind) {\n        next = this.rewind(next);\n      }\n\n      return Splide.index < next && next <= this.edgeIndex || next === 0 ? next : -1;\n    }\n\n  };\n  /**\r\n   * Listen to some events.\r\n   */\n\n  function bind() {\n    Splide.on('move', function (newIndex) {\n      Splide.index = newIndex;\n    }).on('updated refresh', function (newOptions) {\n      options = newOptions || options;\n      Splide.index = between(Splide.index, 0, Controller.edgeIndex);\n    });\n  }\n  /**\r\n   * Verify if the focus option is available or not.\r\n   *\r\n   * @return {boolean} - True if a slider has the focus option.\r\n   */\n\n\n  function hasFocus() {\n    return options.focus !== false;\n  }\n  /**\r\n   * Return the next or previous page index computed by the page number and current index.\r\n   *\r\n   * @param {number}  number - Specify the page number.\r\n   * @param {number}  index  - Current index.\r\n   * @param {boolean} prev   - Prev or next.\r\n   *\r\n   * @return {number} - Slide index.\r\n   */\n\n\n  function parsePage(number, index, prev) {\n    if (number > -1) {\n      return Controller.toIndex(number);\n    }\n\n    var perMove = options.perMove;\n    var sign = prev ? -1 : 1;\n\n    if (perMove) {\n      return index + perMove * sign;\n    }\n\n    return Controller.toIndex(Controller.toPage(index) + sign);\n  }\n\n  return Controller;\n});\n// CONCATENATED MODULE: ./src/js/components/track/index.js\n/**\r\n * The component for moving list in the track.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\nvar abs = Math.abs;\n/**\r\n * The component for moving list in the track.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ var components_track = (function (Splide, Components) {\n  /**\r\n   * Hold the Layout component.\r\n   *\r\n   * @type {Object}\r\n   */\n  var Layout;\n  /**\r\n   * Hold the Layout component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements;\n  /**\r\n   * Store the list element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var list;\n  /**\r\n   * Whether the current direction is vertical or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isVertical = Splide.options.direction === TTB;\n  /**\r\n   * Whether the slider type is FADE or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isFade = Splide.is(FADE);\n  /**\r\n   * Whether the slider direction is RTL or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isRTL = Splide.options.direction === RTL;\n  /**\r\n   * This will be true while transitioning from the last index to the first one.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isLoopPending = false;\n  /**\r\n   * Sign for the direction. Only RTL mode uses the positive sign.\r\n   *\r\n   * @type {number}\r\n   */\n\n  var sign = isRTL ? 1 : -1;\n  /**\r\n   * Track component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Track = {\n    /**\r\n     * Make public the sign defined locally.\r\n     *\r\n     * @type {number}\r\n     */\n    sign: sign,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Elements = Components.Elements;\n      Layout = Components.Layout;\n      list = Elements.list;\n    },\n\n    /**\r\n     * Called after the component is mounted.\r\n     * The resize event must be registered after the Layout's one is done.\r\n     */\n    mounted: function mounted() {\n      var _this = this;\n\n      if (!isFade) {\n        this.jump(0);\n        Splide.on('mounted resize updated', function () {\n          _this.jump(Splide.index);\n        });\n      }\n    },\n\n    /**\r\n     * Go to the given destination index.\r\n     * After arriving there, the track is jump to the new index without animation, mainly for loop mode.\r\n     *\r\n     * @param {number}  destIndex - A destination index.\r\n     *                              This can be negative or greater than slides length for reaching clones.\r\n     * @param {number}  newIndex  - An actual new index. They are always same in Slide and Rewind mode.\r\n     * @param {boolean} silently  - If true, suppress emitting events.\r\n     */\n    go: function go(destIndex, newIndex, silently) {\n      var newPosition = getTrimmedPosition(destIndex);\n      var prevIndex = Splide.index; // Prevent any actions while transitioning from the last index to the first one for jump.\n\n      if (Splide.State.is(MOVING) && isLoopPending) {\n        return;\n      }\n\n      isLoopPending = destIndex !== newIndex;\n\n      if (!silently) {\n        Splide.emit('move', newIndex, prevIndex, destIndex);\n      }\n\n      if (Math.abs(newPosition - this.position) >= 1 || isFade) {\n        Components.Transition.start(destIndex, newIndex, prevIndex, this.toCoord(newPosition), function () {\n          onTransitionEnd(destIndex, newIndex, prevIndex, silently);\n        });\n      } else {\n        if (destIndex !== prevIndex && Splide.options.trimSpace === 'move') {\n          Components.Controller.go(destIndex + destIndex - prevIndex, silently);\n        } else {\n          onTransitionEnd(destIndex, newIndex, prevIndex, silently);\n        }\n      }\n    },\n\n    /**\r\n     * Move the track to the specified index.\r\n     *\r\n     * @param {number} index - A destination index where the track jumps.\r\n     */\n    jump: function jump(index) {\n      this.translate(getTrimmedPosition(index));\n    },\n\n    /**\r\n     * Set the list position by CSS translate property.\r\n     *\r\n     * @param {number} position - A new position value.\r\n     */\n    translate: function translate(position) {\n      applyStyle(list, {\n        transform: \"translate\" + (isVertical ? 'Y' : 'X') + \"(\" + position + \"px)\"\n      });\n    },\n\n    /**\r\n     * Cancel the transition and set the list position.\r\n     * Also, loop the slider if necessary.\r\n     */\n    cancel: function cancel() {\n      if (Splide.is(LOOP)) {\n        this.shift();\n      } else {\n        // Ensure the current position.\n        this.translate(this.position);\n      }\n\n      applyStyle(list, {\n        transition: ''\n      });\n    },\n\n    /**\r\n     * Shift the slider if it exceeds borders on the edge.\r\n     */\n    shift: function shift() {\n      var position = abs(this.position);\n      var left = abs(this.toPosition(0));\n      var right = abs(this.toPosition(Splide.length));\n      var innerSize = right - left;\n\n      if (position < left) {\n        position += innerSize;\n      } else if (position > right) {\n        position -= innerSize;\n      }\n\n      this.translate(sign * position);\n    },\n\n    /**\r\n     * Trim redundant spaces on the left or right edge if necessary.\r\n     *\r\n     * @param {number} position - Position value to be trimmed.\r\n     *\r\n     * @return {number} - Trimmed position.\r\n     */\n    trim: function trim(position) {\n      if (!Splide.options.trimSpace || Splide.is(LOOP)) {\n        return position;\n      }\n\n      var edge = sign * (Layout.totalSize() - Layout.size - Layout.gap);\n      return between(position, edge, 0);\n    },\n\n    /**\r\n     * Calculate the closest slide index from the given position.\r\n     *\r\n     * @param {number} position - A position converted to an slide index.\r\n     *\r\n     * @return {number} - The closest slide index.\r\n     */\n    toIndex: function toIndex(position) {\n      var _this2 = this;\n\n      var index = 0;\n      var minDistance = Infinity;\n      Elements.getSlides(true).forEach(function (Slide) {\n        var slideIndex = Slide.index;\n        var distance = abs(_this2.toPosition(slideIndex) - position);\n\n        if (distance < minDistance) {\n          minDistance = distance;\n          index = slideIndex;\n        }\n      });\n      return index;\n    },\n\n    /**\r\n     * Return coordinates object by the given position.\r\n     *\r\n     * @param {number} position - A position value.\r\n     *\r\n     * @return {Object} - A coordinates object.\r\n     */\n    toCoord: function toCoord(position) {\n      return {\n        x: isVertical ? 0 : position,\n        y: isVertical ? position : 0\n      };\n    },\n\n    /**\r\n     * Calculate the track position by a slide index.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {Object} - Calculated position.\r\n     */\n    toPosition: function toPosition(index) {\n      var position = Layout.totalSize(index) - Layout.slideSize(index) - Layout.gap;\n      return sign * (position + this.offset(index));\n    },\n\n    /**\r\n     * Return the current offset value, considering direction.\r\n     *\r\n     * @return {number} - Offset amount.\r\n     */\n    offset: function offset(index) {\n      var focus = Splide.options.focus;\n      var slideSize = Layout.slideSize(index);\n\n      if (focus === 'center') {\n        return -(Layout.size - slideSize) / 2;\n      }\n\n      return -(parseInt(focus) || 0) * (slideSize + Layout.gap);\n    },\n\n    /**\r\n     * Return the current position.\r\n     * This returns the correct position even while transitioning by CSS.\r\n     *\r\n     * @return {number} - Current position.\r\n     */\n    get position() {\n      var prop = isVertical ? 'top' : isRTL ? 'right' : 'left';\n      return getRect(list)[prop] - (getRect(Elements.track)[prop] - Layout.padding[prop] * sign);\n    }\n\n  };\n  /**\r\n   * Called whenever slides arrive at a destination.\r\n   *\r\n   * @param {number}  destIndex - A destination index.\r\n   * @param {number}  newIndex  - A new index.\r\n   * @param {number}  prevIndex - A previous index.\r\n   * @param {boolean} silently  - If true, suppress emitting events.\r\n   */\n\n  function onTransitionEnd(destIndex, newIndex, prevIndex, silently) {\n    applyStyle(list, {\n      transition: ''\n    });\n    isLoopPending = false;\n\n    if (!isFade) {\n      Track.jump(newIndex);\n    }\n\n    if (!silently) {\n      Splide.emit('moved', newIndex, prevIndex, destIndex);\n    }\n  }\n  /**\r\n   * Convert index to the trimmed position.\r\n   *\r\n   * @return {number} - Trimmed position.\r\n   */\n\n\n  function getTrimmedPosition(index) {\n    return Track.trim(Track.toPosition(index));\n  }\n\n  return Track;\n});\n// CONCATENATED MODULE: ./src/js/components/clones/index.js\n/**\r\n * The component for cloning some slides for \"loop\" mode of the track.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n/**\r\n * The component for cloning some slides for \"loop\" mode of the track.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ var components_clones = (function (Splide, Components) {\n  /**\r\n   * Store information of all clones.\r\n   *\r\n   * @type {Array}\r\n   */\n  var clones = [];\n  /**\r\n   * Store the current clone count on one side.\r\n   *\r\n   * @type {number}\r\n   */\n\n  var cloneCount = 0;\n  /**\r\n   * Keep Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * Clones component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Clones = {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      var _this = this;\n\n      if (Splide.is(LOOP)) {\n        init();\n        Splide.on('refresh', init).on('resize', function () {\n          if (cloneCount !== getCloneCount()) {\n            // Destroy before refresh not to collect clones by the Elements component.\n            _this.destroy();\n\n            Splide.refresh();\n          }\n        });\n      }\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      dom_remove(clones);\n      clones = [];\n    },\n\n    /**\r\n     * Return all clones.\r\n     *\r\n     * @return {Element[]} - Cloned elements.\r\n     */\n    get clones() {\n      return clones;\n    },\n\n    /**\r\n     * Return clone length.\r\n     *\r\n     * @return {number} - A length of clones.\r\n     */\n    get length() {\n      return clones.length;\n    }\n\n  };\n  /**\r\n   * Initialization.\r\n   */\n\n  function init() {\n    Clones.destroy();\n    cloneCount = getCloneCount();\n    generateClones(cloneCount);\n  }\n  /**\r\n   * Generate and append/prepend clones.\r\n   *\r\n   * @param {number} count - The half number of clones.\r\n   */\n\n\n  function generateClones(count) {\n    var length = Elements.length,\n        register = Elements.register;\n\n    if (length) {\n      var slides = Elements.slides;\n\n      while (slides.length < count) {\n        slides = slides.concat(slides);\n      } // Clones after the last element.\n\n\n      slides.slice(0, count).forEach(function (elm, index) {\n        var clone = cloneDeeply(elm);\n        append(Elements.list, clone);\n        clones.push(clone);\n        register(clone, index + length, index % length);\n      }); // Clones before the first element.\n\n      slides.slice(-count).forEach(function (elm, index) {\n        var clone = cloneDeeply(elm);\n        before(clone, slides[0]);\n        clones.push(clone);\n        register(clone, index - count, (length + index - count % length) % length);\n      });\n    }\n  }\n  /**\r\n   * Return half count of clones to be generated.\r\n   * Clone count is determined by:\r\n   * - \"clones\" value in the options.\r\n   * - Number of slides that can be placed in a view in \"fixed\" mode.\r\n   * - Max pages a flick action can move.\r\n   * - Whether the slide length is enough for perPage.\r\n   *\r\n   * @return {number} - Count for clones.\r\n   */\n\n\n  function getCloneCount() {\n    var options = Splide.options;\n\n    if (options.clones) {\n      return options.clones;\n    } // Use the slide length in autoWidth mode because the number cannot be calculated.\n\n\n    var baseCount = options.autoWidth || options.autoHeight ? Elements.length : options.perPage;\n    var dimension = options.direction === TTB ? 'Height' : 'Width';\n    var fixedSize = toPixel(Splide.root, options[\"fixed\" + dimension]);\n\n    if (fixedSize) {\n      // Roughly calculate the count. This needs not to be strict.\n      baseCount = Math.ceil(Elements.track[\"client\" + dimension] / fixedSize);\n    }\n\n    return baseCount * (options.drag ? options.flickMaxPages + 1 : 1);\n  }\n  /**\r\n   * Clone deeply the given element.\r\n   *\r\n   * @param {Element} elm - An element being duplicated.\r\n   *\r\n   * @return {Node} - A cloned node(element).\r\n   */\n\n\n  function cloneDeeply(elm) {\n    var clone = elm.cloneNode(true);\n    addClass(clone, Splide.classes.clone); // ID should not be duplicated.\n\n    removeAttribute(clone, 'id');\n    return clone;\n  }\n\n  return Clones;\n});\n// CONCATENATED MODULE: ./src/js/components/layout/directions/horizontal.js\n/**\r\n * The resolver component for horizontal layout.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The resolver component for horizontal layout.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The resolver object.\r\n */\n\n/* harmony default export */ var horizontal = (function (Splide, Components) {\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\n  var Elements = Components.Elements;\n  /**\r\n   * Keep the root element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var root = Splide.root;\n  /**\r\n   * Keep the track element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var track;\n  /**\r\n   * Keep the latest options.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var options = Splide.options;\n  return {\n    /**\r\n     * Margin property name.\r\n     *\r\n     * @type {string}\r\n     */\n    margin: 'margin' + (options.direction === RTL ? 'Left' : 'Right'),\n\n    /**\r\n     * Always 0 because the height will be determined by inner contents.\r\n     *\r\n     * @type {number}\r\n     */\n    height: 0,\n\n    /**\r\n     * Initialization.\r\n     */\n    init: function init() {\n      this.resize();\n    },\n\n    /**\r\n     * Resize gap and padding.\r\n     * This must be called on init.\r\n     */\n    resize: function resize() {\n      options = Splide.options;\n      track = Elements.track;\n      this.gap = toPixel(root, options.gap);\n      var padding = options.padding;\n      var left = toPixel(root, padding.left || padding);\n      var right = toPixel(root, padding.right || padding);\n      this.padding = {\n        left: left,\n        right: right\n      };\n      applyStyle(track, {\n        paddingLeft: unit(left),\n        paddingRight: unit(right)\n      });\n    },\n\n    /**\r\n     * Return total width from the left of the list to the right of the slide specified by the provided index.\r\n     *\r\n     * @param {number} index - Optional. A slide index. If undefined, total width of the slider will be returned.\r\n     *\r\n     * @return {number} - Total width to the right side of the specified slide, or 0 for an invalid index.\r\n     */\n    totalWidth: function totalWidth(index) {\n      if (index === void 0) {\n        index = Splide.length - 1;\n      }\n\n      var Slide = Elements.getSlide(index);\n      var width = 0;\n\n      if (Slide) {\n        var slideRect = getRect(Slide.slide);\n        var listRect = getRect(Elements.list);\n\n        if (options.direction === RTL) {\n          width = listRect.right - slideRect.left;\n        } else {\n          width = slideRect.right - listRect.left;\n        }\n\n        width += this.gap;\n      }\n\n      return width;\n    },\n\n    /**\r\n     * Return the slide width in px.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {number} - The slide width.\r\n     */\n    slideWidth: function slideWidth(index) {\n      if (options.autoWidth) {\n        var Slide = Elements.getSlide(index);\n        return Slide ? Slide.slide.offsetWidth : 0;\n      }\n\n      var width = options.fixedWidth || (this.width + this.gap) / options.perPage - this.gap;\n      return toPixel(root, width);\n    },\n\n    /**\r\n     * Return the slide height in px.\r\n     *\r\n     * @return {number} - The slide height.\r\n     */\n    slideHeight: function slideHeight() {\n      var height = options.height || options.fixedHeight || this.width * options.heightRatio;\n      return toPixel(root, height);\n    },\n\n    /**\r\n     * Return slider width without padding.\r\n     *\r\n     * @return {number} - Current slider width.\r\n     */\n    get width() {\n      return track.clientWidth - this.padding.left - this.padding.right;\n    }\n\n  };\n});\n// CONCATENATED MODULE: ./src/js/components/layout/directions/vertical.js\n/**\r\n * The resolver component for vertical layout.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The resolver component for vertical layout.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The resolver object.\r\n */\n\n/* harmony default export */ var vertical = (function (Splide, Components) {\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\n  var Elements = Components.Elements;\n  /**\r\n   * Keep the root element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var root = Splide.root;\n  /**\r\n   * Keep the track element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var track;\n  /**\r\n   * Keep the latest options.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var options;\n  return {\n    /**\r\n     * Margin property name.\r\n     *\r\n     * @type {string}\r\n     */\n    margin: 'marginBottom',\n\n    /**\r\n     * Initialization.\r\n     */\n    init: function init() {\n      this.resize();\n    },\n\n    /**\r\n     * Resize gap and padding.\r\n     * This must be called on init.\r\n     */\n    resize: function resize() {\n      options = Splide.options;\n      track = Elements.track;\n      this.gap = toPixel(root, options.gap);\n      var padding = options.padding;\n      var top = toPixel(root, padding.top || padding);\n      var bottom = toPixel(root, padding.bottom || padding);\n      this.padding = {\n        top: top,\n        bottom: bottom\n      };\n      applyStyle(track, {\n        paddingTop: unit(top),\n        paddingBottom: unit(bottom)\n      });\n    },\n\n    /**\r\n     * Return total height from the top of the list to the bottom of the slide specified by the provided index.\r\n     *\r\n     * @param {number} index - Optional. A slide index. If undefined, total height of the slider will be returned.\r\n     *\r\n     * @return {number} - Total height to the bottom of the specified slide, or 0 for an invalid index.\r\n     */\n    totalHeight: function totalHeight(index) {\n      if (index === void 0) {\n        index = Splide.length - 1;\n      }\n\n      var Slide = Elements.getSlide(index);\n\n      if (Slide) {\n        return getRect(Slide.slide).bottom - getRect(Elements.list).top + this.gap;\n      }\n\n      return 0;\n    },\n\n    /**\r\n     * Return the slide width in px.\r\n     *\r\n     * @return {number} - The slide width.\r\n     */\n    slideWidth: function slideWidth() {\n      return toPixel(root, options.fixedWidth || this.width);\n    },\n\n    /**\r\n     * Return the slide height in px.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {number} - The slide height.\r\n     */\n    slideHeight: function slideHeight(index) {\n      if (options.autoHeight) {\n        var Slide = Elements.getSlide(index);\n        return Slide ? Slide.slide.offsetHeight : 0;\n      }\n\n      var height = options.fixedHeight || (this.height + this.gap) / options.perPage - this.gap;\n      return toPixel(root, height);\n    },\n\n    /**\r\n     * Return slider width without padding.\r\n     *\r\n     * @return {number} - Current slider width.\r\n     */\n    get width() {\n      return track.clientWidth;\n    },\n\n    /**\r\n     * Return slide height without padding.\r\n     *\r\n     * @return {number} - Slider height.\r\n     */\n    get height() {\n      var height = options.height || this.width * options.heightRatio;\n      exist(height, '\"height\" or \"heightRatio\" is missing.');\n      return toPixel(root, height) - this.padding.top - this.padding.bottom;\n    }\n\n  };\n});\n// CONCATENATED MODULE: ./src/js/utils/time.js\n/**\r\n * A package of utility functions related with time.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Simple throttle function that controls how often the given function is executed.\r\n *\r\n * @param {function} func - A function to be throttled.\r\n * @param {number}   wait - Time in millisecond for interval of execution.\r\n *\r\n * @return {Function} - A debounced function.\r\n */\nfunction throttle(func, wait) {\n  var timeout; // Declare function by the \"function\" keyword to prevent \"this\" from being inherited.\n\n  return function () {\n    if (!timeout) {\n      timeout = setTimeout(function () {\n        func();\n        timeout = null;\n      }, wait);\n    }\n  };\n}\n/**\r\n * Custom setInterval function that provides progress rate as callback.\r\n *\r\n * @param {function} callback - A callback function fired every time the interval time passes.\r\n * @param {number}   interval - Interval duration in milliseconds.\r\n * @param {function} progress - A callback function fired whenever the progress goes.\r\n *\r\n * @return {Object} - An object containing play() and pause() functions.\r\n */\n\nfunction createInterval(callback, interval, progress) {\n  var _window = window,\n      requestAnimationFrame = _window.requestAnimationFrame;\n  var start,\n      elapse,\n      rate,\n      _pause = true;\n\n  var step = function step(timestamp) {\n    if (!_pause) {\n      if (!start) {\n        start = timestamp;\n\n        if (rate && rate < 1) {\n          start -= rate * interval;\n        }\n      }\n\n      elapse = timestamp - start;\n      rate = elapse / interval;\n\n      if (elapse >= interval) {\n        start = 0;\n        rate = 1;\n        callback();\n      }\n\n      if (progress) {\n        progress(rate);\n      }\n\n      requestAnimationFrame(step);\n    }\n  };\n\n  return {\n    pause: function pause() {\n      _pause = true;\n      start = 0;\n    },\n    play: function play(reset) {\n      start = 0;\n\n      if (_pause) {\n        _pause = false;\n\n        if (reset) {\n          rate = 0;\n        }\n\n        requestAnimationFrame(step);\n      }\n    }\n  };\n}\n// CONCATENATED MODULE: ./src/js/components/layout/index.js\n/**\r\n * The component for handing slide layouts and their sizes.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n\n\n/**\r\n * The component for handing slide layouts and their sizes.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ var layout = (function (Splide, Components) {\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\n  var Elements = Components.Elements;\n  /**\r\n   * Whether the slider is vertical or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isVertical = Splide.options.direction === TTB;\n  /**\r\n   * Layout component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Layout = object_assign({\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      bind();\n      init(); // The word \"size\" means width for a horizontal slider and height for a vertical slider.\n\n      this.totalSize = isVertical ? this.totalHeight : this.totalWidth;\n      this.slideSize = isVertical ? this.slideHeight : this.slideWidth;\n    },\n\n    /**\r\n     * Destroy the component.\r\n     */\n    destroy: function destroy() {\n      removeAttribute([Elements.list, Elements.track], 'style');\n    },\n\n    /**\r\n     * Return the slider height on the vertical mode or width on the horizontal mode.\r\n     *\r\n     * @return {number}\r\n     */\n    get size() {\n      return isVertical ? this.height : this.width;\n    }\n\n  }, isVertical ? vertical(Splide, Components) : horizontal(Splide, Components));\n  /**\r\n   * Init slider styles according to options.\r\n   */\n\n  function init() {\n    Layout.init();\n    applyStyle(Splide.root, {\n      maxWidth: unit(Splide.options.width)\n    });\n    Elements.each(function (Slide) {\n      Slide.slide.style[Layout.margin] = unit(Layout.gap);\n    });\n    resize();\n  }\n  /**\r\n   * Listen the resize native event with throttle.\r\n   * Initialize when the component is mounted or options are updated.\r\n   */\n\n\n  function bind() {\n    Splide.on('resize load', throttle(function () {\n      Splide.emit('resize');\n    }, Splide.options.throttle), window).on('resize', resize).on('updated refresh', init);\n  }\n  /**\r\n   * Resize the track and slide elements.\r\n   */\n\n\n  function resize() {\n    var options = Splide.options;\n    Layout.resize();\n    applyStyle(Elements.track, {\n      height: unit(Layout.height)\n    });\n    var slideHeight = options.autoHeight ? null : unit(Layout.slideHeight());\n    Elements.each(function (Slide) {\n      applyStyle(Slide.container, {\n        height: slideHeight\n      });\n      applyStyle(Slide.slide, {\n        width: options.autoWidth ? null : unit(Layout.slideWidth(Slide.index)),\n        height: Slide.container ? null : slideHeight\n      });\n    });\n  }\n\n  return Layout;\n});\n// CONCATENATED MODULE: ./src/js/components/drag/index.js\n/**\r\n * The component for supporting mouse drag and swipe.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\nvar drag_abs = Math.abs;\n/**\r\n * If the absolute velocity is greater thant this value,\r\n * a slider always goes to a different slide after drag, not allowed to stay on a current slide.\r\n */\n\nvar MIN_VELOCITY = 0.1;\n/**\r\n * Adjust how much the track can be pulled on the first or last page.\r\n * The larger number this is, the farther the track moves.\r\n * This should be around 5 - 9.\r\n *\r\n * @type {number}\r\n */\n\nvar FRICTION_REDUCER = 7;\n/**\r\n * The component supporting mouse drag and swipe.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ var drag = (function (Splide, Components) {\n  /**\r\n   * Store the Move component.\r\n   *\r\n   * @type {Object}\r\n   */\n  var Track = Components.Track;\n  /**\r\n   * Store the Controller component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Controller = Components.Controller;\n  /**\r\n   * Coordinate of the track on starting drag.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var startCoord;\n  /**\r\n   * Analyzed info on starting drag.\r\n   *\r\n   * @type {Object|null}\r\n   */\n\n  var startInfo;\n  /**\r\n   * Analyzed info being updated while dragging/swiping.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var currentInfo;\n  /**\r\n   * Determine whether slides are being dragged or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isDragging;\n  /**\r\n   * Whether the slider direction is vertical or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isVertical = Splide.options.direction === TTB;\n  /**\r\n   * Axis for the direction.\r\n   *\r\n   * @type {string}\r\n   */\n\n  var axis = isVertical ? 'y' : 'x';\n  /**\r\n   * Drag component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Drag = {\n    /**\r\n     * Whether dragging is disabled or not.\r\n     *\r\n     * @type {boolean}\r\n     */\n    disabled: false,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      var _this = this;\n\n      var Elements = Components.Elements;\n      var track = Elements.track;\n      Splide.on('touchstart mousedown', start, track).on('touchmove mousemove', move, track, {\n        passive: false\n      }).on('touchend touchcancel mouseleave mouseup dragend', end, track).on('mounted refresh', function () {\n        // Prevent dragging an image or anchor itself.\n        each(Elements.list.querySelectorAll('img, a'), function (elm) {\n          Splide.off('dragstart', elm).on('dragstart', function (e) {\n            e.preventDefault();\n          }, elm, {\n            passive: false\n          });\n        });\n      }).on('mounted updated', function () {\n        _this.disabled = !Splide.options.drag;\n      });\n    }\n  };\n  /**\r\n   * Called when the track starts to be dragged.\r\n   *\r\n   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n   */\n\n  function start(e) {\n    if (!Drag.disabled && !isDragging) {\n      // These prams are used to evaluate whether the slider should start moving.\n      init(e);\n    }\n  }\n  /**\r\n   * Initialize parameters.\r\n   *\r\n   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n   */\n\n\n  function init(e) {\n    startCoord = Track.toCoord(Track.position);\n    startInfo = analyze(e, {});\n    currentInfo = startInfo;\n  }\n  /**\r\n   * Called while the track being dragged.\r\n   *\r\n   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n   */\n\n\n  function move(e) {\n    if (startInfo) {\n      currentInfo = analyze(e, startInfo);\n\n      if (isDragging) {\n        if (e.cancelable) {\n          e.preventDefault();\n        }\n\n        if (!Splide.is(FADE)) {\n          var position = startCoord[axis] + currentInfo.offset[axis];\n          Track.translate(resist(position));\n        }\n      } else {\n        if (shouldMove(currentInfo)) {\n          Splide.emit('drag', startInfo);\n          isDragging = true;\n          Track.cancel(); // These params are actual drag data.\n\n          init(e);\n        }\n      }\n    }\n  }\n  /**\r\n   * Determine whether to start moving the track or not by drag angle.\r\n   *\r\n   * @param {Object} info - An information object.\r\n   *\r\n   * @return {boolean} - True if the track should be moved or false if not.\r\n   */\n\n\n  function shouldMove(_ref) {\n    var offset = _ref.offset;\n\n    if (Splide.State.is(MOVING) && Splide.options.waitForTransition) {\n      return false;\n    }\n\n    var angle = Math.atan(drag_abs(offset.y) / drag_abs(offset.x)) * 180 / Math.PI;\n\n    if (isVertical) {\n      angle = 90 - angle;\n    }\n\n    return angle < Splide.options.dragAngleThreshold;\n  }\n  /**\r\n   * Resist dragging the track on the first/last page because there is no more.\r\n   *\r\n   * @param {number} position - A position being applied to the track.\r\n   *\r\n   * @return {Object} - Adjusted position.\r\n   */\n\n\n  function resist(position) {\n    if (Splide.is(SLIDE)) {\n      var sign = Track.sign;\n\n      var _start = sign * Track.trim(Track.toPosition(0));\n\n      var _end = sign * Track.trim(Track.toPosition(Controller.edgeIndex));\n\n      position *= sign;\n\n      if (position < _start) {\n        position = _start - FRICTION_REDUCER * Math.log(_start - position);\n      } else if (position > _end) {\n        position = _end + FRICTION_REDUCER * Math.log(position - _end);\n      }\n\n      position *= sign;\n    }\n\n    return position;\n  }\n  /**\r\n   * Called when dragging ends.\r\n   */\n\n\n  function end() {\n    startInfo = null;\n\n    if (isDragging) {\n      Splide.emit('dragged', currentInfo);\n      go(currentInfo);\n      isDragging = false;\n    }\n  }\n  /**\r\n   * Go to the slide determined by the analyzed data.\r\n   *\r\n   * @param {Object} info - An info object.\r\n   */\n\n\n  function go(info) {\n    var velocity = info.velocity[axis];\n    var absV = drag_abs(velocity);\n\n    if (absV > 0) {\n      var options = Splide.options;\n      var index = Splide.index;\n      var sign = velocity < 0 ? -1 : 1;\n      var destIndex = index;\n\n      if (!Splide.is(FADE)) {\n        var destination = Track.position;\n\n        if (absV > options.flickVelocityThreshold && drag_abs(info.offset[axis]) < options.swipeDistanceThreshold) {\n          destination += sign * Math.min(absV * options.flickPower, Components.Layout.size * (options.flickMaxPages || 1));\n        }\n\n        destIndex = Track.toIndex(destination);\n      }\n      /*\r\n       * Do not allow the track to go to a previous position if there is enough velocity.\r\n       * Always use the adjacent index for the fade mode.\r\n       */\n\n\n      if (destIndex === index && absV > MIN_VELOCITY) {\n        destIndex = index + sign * Track.sign;\n      }\n\n      if (Splide.is(SLIDE)) {\n        destIndex = between(destIndex, 0, Controller.edgeIndex);\n      }\n\n      Controller.go(destIndex, options.isNavigation);\n    }\n  }\n  /**\r\n   * Analyze the given event object and return important information for handling swipe behavior.\r\n   *\r\n   * @param {Event}   e          - Touch or Mouse event object.\r\n   * @param {Object}  startInfo  - Information analyzed on start for calculating difference from the current one.\r\n   *\r\n   * @return {Object} - An object containing analyzed information, such as offset, velocity, etc.\r\n   */\n\n\n  function analyze(e, startInfo) {\n    var timeStamp = e.timeStamp,\n        touches = e.touches;\n\n    var _ref2 = touches ? touches[0] : e,\n        clientX = _ref2.clientX,\n        clientY = _ref2.clientY;\n\n    var _ref3 = startInfo.to || {},\n        _ref3$x = _ref3.x,\n        fromX = _ref3$x === void 0 ? clientX : _ref3$x,\n        _ref3$y = _ref3.y,\n        fromY = _ref3$y === void 0 ? clientY : _ref3$y;\n\n    var startTime = startInfo.time || 0;\n    var offset = {\n      x: clientX - fromX,\n      y: clientY - fromY\n    };\n    var duration = timeStamp - startTime;\n    var velocity = {\n      x: offset.x / duration,\n      y: offset.y / duration\n    };\n    return {\n      to: {\n        x: clientX,\n        y: clientY\n      },\n      offset: offset,\n      time: timeStamp,\n      velocity: velocity\n    };\n  }\n\n  return Drag;\n});\n// CONCATENATED MODULE: ./src/js/components/click/index.js\n/**\r\n * The component for handling a click event.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The component for handling a click event.\r\n * Click should be disabled during drag/swipe.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ var click = (function (Splide, Components) {\n  /**\r\n   * Whether click is disabled or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  var disabled = false;\n  /**\r\n   * Click component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Click = {\n    /**\r\n     * Mount only when the drag is activated and the slide type is not \"fade\".\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: Splide.options.drag,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('click', onClick, Components.Elements.track, {\n        capture: true\n      }).on('drag', function () {\n        disabled = true;\n      }).on('moved', function () {\n        disabled = false;\n      });\n    }\n  };\n  /**\r\n   * Called when a track element is clicked.\r\n   *\r\n   * @param {Event} e - A click event.\r\n   */\n\n  function onClick(e) {\n    if (disabled) {\n      e.preventDefault();\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n\n  return Click;\n});\n// CONCATENATED MODULE: ./src/js/components/autoplay/index.js\n/**\r\n * The component for playing slides automatically.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Set of pause flags.\r\n */\n\nvar PAUSE_FLAGS = {\n  HOVER: 1,\n  FOCUS: 2,\n  MANUAL: 3\n};\n/**\r\n * The component for playing slides automatically.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ var components_autoplay = (function (Splide, Components, name) {\n  /**\r\n   * Store pause flags.\r\n   *\r\n   * @type {Array}\r\n   */\n  var flags = [];\n  /**\r\n   * Store an interval object.\r\n   *\r\n   * @type {Object};\r\n   */\n\n  var interval;\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * Autoplay component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Autoplay = {\n    /**\r\n     * Required only when the autoplay option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: Splide.options.autoplay,\n\n    /**\r\n     * Called when the component is mounted.\r\n     * Note that autoplay starts only if there are slides over perPage number.\r\n     */\n    mount: function mount() {\n      var options = Splide.options;\n\n      if (Elements.slides.length > options.perPage) {\n        interval = createInterval(function () {\n          Splide.go('>');\n        }, options.interval, function (rate) {\n          Splide.emit(name + \":playing\", rate);\n\n          if (Elements.bar) {\n            applyStyle(Elements.bar, {\n              width: rate * 100 + \"%\"\n            });\n          }\n        });\n        bind();\n        this.play();\n      }\n    },\n\n    /**\r\n     * Start autoplay.\r\n     *\r\n     * @param {number} flag - A pause flag to be removed.\r\n     */\n    play: function play(flag) {\n      if (flag === void 0) {\n        flag = 0;\n      }\n\n      flags = flags.filter(function (f) {\n        return f !== flag;\n      });\n\n      if (!flags.length) {\n        Splide.emit(name + \":play\");\n        interval.play(Splide.options.resetProgress);\n      }\n    },\n\n    /**\r\n     * Pause autoplay.\r\n     * Note that Array.includes is not supported by IE.\r\n     *\r\n     * @param {number} flag - A pause flag to be added.\r\n     */\n    pause: function pause(flag) {\n      if (flag === void 0) {\n        flag = 0;\n      }\n\n      interval.pause();\n\n      if (flags.indexOf(flag) === -1) {\n        flags.push(flag);\n      }\n\n      if (flags.length === 1) {\n        Splide.emit(name + \":pause\");\n      }\n    }\n  };\n  /**\r\n   * Listen some events.\r\n   */\n\n  function bind() {\n    var options = Splide.options;\n    var sibling = Splide.sibling;\n    var elms = [Splide.root, sibling ? sibling.root : null];\n\n    if (options.pauseOnHover) {\n      switchOn(elms, 'mouseleave', PAUSE_FLAGS.HOVER, true);\n      switchOn(elms, 'mouseenter', PAUSE_FLAGS.HOVER, false);\n    }\n\n    if (options.pauseOnFocus) {\n      switchOn(elms, 'focusout', PAUSE_FLAGS.FOCUS, true);\n      switchOn(elms, 'focusin', PAUSE_FLAGS.FOCUS, false);\n    }\n\n    if (Elements.play) {\n      Splide.on('click', function () {\n        // Need to be removed a focus flag at first.\n        Autoplay.play(PAUSE_FLAGS.FOCUS);\n        Autoplay.play(PAUSE_FLAGS.MANUAL);\n      }, Elements.play);\n    }\n\n    if (Elements.pause) {\n      switchOn([Elements.pause], 'click', PAUSE_FLAGS.MANUAL, false);\n    }\n\n    Splide.on('move refresh', function () {\n      Autoplay.play();\n    }) // Rewind the timer.\n    .on('destroy', function () {\n      Autoplay.pause();\n    });\n  }\n  /**\r\n   * Play or pause on the given event.\r\n   *\r\n   * @param {Element[]} elms  - Elements.\r\n   * @param {string}    event - An event name or names.\r\n   * @param {number}    flag  - A pause flag defined on the top.\r\n   * @param {boolean}   play  - Determine whether to play or pause.\r\n   */\n\n\n  function switchOn(elms, event, flag, play) {\n    elms.forEach(function (elm) {\n      Splide.on(event, function () {\n        Autoplay[play ? 'play' : 'pause'](flag);\n      }, elm);\n    });\n  }\n\n  return Autoplay;\n});\n// CONCATENATED MODULE: ./src/js/components/cover/index.js\n/**\r\n * The component for change an img element to background image of its wrapper.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The component for change an img element to background image of its wrapper.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ var components_cover = (function (Splide, Components) {\n  /**\r\n   * Hold options.\r\n   *\r\n   * @type {Object}\r\n   */\n  var options = Splide.options;\n  /**\r\n   * Cover component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Cover = {\n    /**\r\n     * Required only when \"cover\" option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: options.cover,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('lazyload:loaded', function (img) {\n        cover(img, false);\n      });\n      Splide.on('mounted updated refresh', function () {\n        return apply(false);\n      });\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      apply(true);\n    }\n  };\n  /**\r\n   * Apply \"cover\" to all slides.\r\n   *\r\n   * @param {boolean} uncover - If true, \"cover\" will be clear.\r\n   */\n\n  function apply(uncover) {\n    Components.Elements.each(function (Slide) {\n      var img = child(Slide.slide, 'IMG') || child(Slide.container, 'IMG');\n\n      if (img && img.src) {\n        cover(img, uncover);\n      }\n    });\n  }\n  /**\r\n   * Set background image of the parent element, using source of the given image element.\r\n   *\r\n   * @param {Element} img     - An image element.\r\n   * @param {boolean} uncover - Reset \"cover\".\r\n   */\n\n\n  function cover(img, uncover) {\n    applyStyle(img.parentElement, {\n      background: uncover ? '' : \"center/cover no-repeat url(\\\"\" + img.src + \"\\\")\"\n    });\n    applyStyle(img, {\n      display: uncover ? '' : 'none'\n    });\n  }\n\n  return Cover;\n});\n// CONCATENATED MODULE: ./src/js/components/arrows/path.js\n/**\r\n * Export vector path for an arrow.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Namespace definition for SVG element.\r\n *\r\n * @type {string}\r\n */\nvar XML_NAME_SPACE = 'http://www.w3.org/2000/svg';\n/**\r\n * The arrow vector path.\r\n *\r\n * @type {number}\r\n */\n\nvar PATH = 'm15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z';\n/**\r\n * SVG width and height.\r\n *\r\n * @type {number}\r\n */\n\nvar SIZE = 40;\n// CONCATENATED MODULE: ./src/js/components/arrows/index.js\n/**\r\n * The component for appending prev/next arrows.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The component for appending prev/next arrows.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ var components_arrows = (function (Splide, Components, name) {\n  /**\r\n   * Previous arrow element.\r\n   *\r\n   * @type {Element|undefined}\r\n   */\n  var prev;\n  /**\r\n   * Next arrow element.\r\n   *\r\n   * @type {Element|undefined}\r\n   */\n\n  var next;\n  /**\r\n   * Store the class list.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var classes = Splide.classes;\n  /**\r\n   * Hold the root element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var root = Splide.root;\n  /**\r\n   * Whether arrows are created programmatically or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var created;\n  /**\r\n   * Hold the Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * Arrows component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Arrows = {\n    /**\r\n     * Required when the arrows option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: Splide.options.arrows,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      // Attempt to get arrows from HTML source.\n      prev = Elements.arrows.prev;\n      next = Elements.arrows.next; // If arrows were not found in HTML, let's generate them.\n\n      if ((!prev || !next) && Splide.options.arrows) {\n        prev = createArrow(true);\n        next = createArrow(false);\n        created = true;\n        appendArrows();\n      }\n\n      if (prev && next) {\n        bind();\n      }\n\n      this.arrows = {\n        prev: prev,\n        next: next\n      };\n    },\n\n    /**\r\n     * Called after all components are mounted.\r\n     */\n    mounted: function mounted() {\n      Splide.emit(name + \":mounted\", prev, next);\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      removeAttribute([prev, next], 'disabled');\n\n      if (created) {\n        dom_remove(prev.parentElement);\n      }\n    }\n  };\n  /**\r\n   * Listen to native and custom events.\r\n   */\n\n  function bind() {\n    Splide.on('click', function () {\n      Splide.go('<');\n    }, prev).on('click', function () {\n      Splide.go('>');\n    }, next).on('mounted move updated refresh', updateDisabled);\n  }\n  /**\r\n   * Update a disabled attribute.\r\n   */\n\n\n  function updateDisabled() {\n    var _Components$Controlle = Components.Controller,\n        prevIndex = _Components$Controlle.prevIndex,\n        nextIndex = _Components$Controlle.nextIndex;\n    var isEnough = Splide.length > Splide.options.perPage || Splide.is(LOOP);\n    prev.disabled = prevIndex < 0 || !isEnough;\n    next.disabled = nextIndex < 0 || !isEnough;\n    Splide.emit(name + \":updated\", prev, next, prevIndex, nextIndex);\n  }\n  /**\r\n   * Create a wrapper element and append arrows.\r\n   */\n\n\n  function appendArrows() {\n    var wrapper = create('div', {\n      \"class\": classes.arrows\n    });\n    append(wrapper, prev);\n    append(wrapper, next);\n    var slider = Elements.slider;\n    var parent = Splide.options.arrows === 'slider' && slider ? slider : root;\n    before(wrapper, parent.firstElementChild);\n  }\n  /**\r\n   * Create an arrow element.\r\n   *\r\n   * @param {boolean} prev - Determine to create a prev arrow or next arrow.\r\n   *\r\n   * @return {Element} - A created arrow element.\r\n   */\n\n\n  function createArrow(prev) {\n    var arrow = \"<button class=\\\"\" + classes.arrow + \" \" + (prev ? classes.prev : classes.next) + \"\\\" type=\\\"button\\\">\" + (\"<svg xmlns=\\\"\" + XML_NAME_SPACE + \"\\\"\\tviewBox=\\\"0 0 \" + SIZE + \" \" + SIZE + \"\\\"\\twidth=\\\"\" + SIZE + \"\\\"\\theight=\\\"\" + SIZE + \"\\\">\") + (\"<path d=\\\"\" + (Splide.options.arrowPath || PATH) + \"\\\" />\");\n    return domify(arrow);\n  }\n\n  return Arrows;\n});\n// CONCATENATED MODULE: ./src/js/components/pagination/index.js\n/**\r\n * The component for handling pagination\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * The event name for updating some attributes of pagination nodes.\r\n *\r\n * @type {string}\r\n */\n\nvar ATTRIBUTES_UPDATE_EVENT = 'move.page';\n/**\r\n * The event name for recreating pagination.\r\n *\r\n * @type {string}\r\n */\n\nvar UPDATE_EVENT = 'updated.page refresh.page';\n/**\r\n * The component for handling pagination\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ var components_pagination = (function (Splide, Components, name) {\n  /**\r\n   * Store all data for pagination.\r\n   * - list: A list element.\r\n   * - items: An array that contains objects(li, button, index, page).\r\n   *\r\n   * @type {Object}\r\n   */\n  var data = {};\n  /**\r\n   * Hold the Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * Pagination component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Pagination = {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      var pagination = Splide.options.pagination;\n\n      if (pagination) {\n        data = createPagination();\n        var slider = Elements.slider;\n        var parent = pagination === 'slider' && slider ? slider : Splide.root;\n        append(parent, data.list);\n        Splide.on(ATTRIBUTES_UPDATE_EVENT, updateAttributes);\n      }\n\n      Splide.off(UPDATE_EVENT).on(UPDATE_EVENT, function () {\n        Pagination.destroy();\n\n        if (Splide.options.pagination) {\n          Pagination.mount();\n          Pagination.mounted();\n        }\n      });\n    },\n\n    /**\r\n     * Called after all components are mounted.\r\n     */\n    mounted: function mounted() {\n      if (Splide.options.pagination) {\n        var index = Splide.index;\n        Splide.emit(name + \":mounted\", data, this.getItem(index));\n        updateAttributes(index, -1);\n      }\n    },\n\n    /**\r\n     * Destroy the pagination.\r\n     * Be aware that node.remove() is not supported by IE.\r\n     */\n    destroy: function destroy() {\n      dom_remove(data.list);\n\n      if (data.items) {\n        data.items.forEach(function (item) {\n          Splide.off('click', item.button);\n        });\n      } // Do not remove UPDATE_EVENT to recreate pagination if needed.\n\n\n      Splide.off(ATTRIBUTES_UPDATE_EVENT);\n      data = {};\n    },\n\n    /**\r\n     * Return an item by index.\r\n     *\r\n     * @param {number} index - A slide index.\r\n     *\r\n     * @return {Object|undefined} - An item object on success or undefined on failure.\r\n     */\n    getItem: function getItem(index) {\n      return data.items[Components.Controller.toPage(index)];\n    },\n\n    /**\r\n     * Return object containing pagination data.\r\n     *\r\n     * @return {Object} - Pagination data including list and items.\r\n     */\n    get data() {\n      return data;\n    }\n\n  };\n  /**\r\n   * Update attributes.\r\n   *\r\n   * @param {number} index     - Active index.\r\n   * @param {number} prevIndex - Prev index.\r\n   */\n\n  function updateAttributes(index, prevIndex) {\n    var prev = Pagination.getItem(prevIndex);\n    var curr = Pagination.getItem(index);\n    var active = STATUS_CLASSES.active;\n\n    if (prev) {\n      removeClass(prev.button, active);\n    }\n\n    if (curr) {\n      addClass(curr.button, active);\n    }\n\n    Splide.emit(name + \":updated\", data, prev, curr);\n  }\n  /**\r\n   * Create a wrapper and button elements.\r\n   *\r\n   * @return {Object} - An object contains all data.\r\n   */\n\n\n  function createPagination() {\n    var options = Splide.options;\n    var classes = Splide.classes;\n    var list = create('ul', {\n      \"class\": classes.pagination\n    });\n    var items = Elements.getSlides(false).filter(function (Slide) {\n      return options.focus !== false || Slide.index % options.perPage === 0;\n    }).map(function (Slide, page) {\n      var li = create('li', {});\n      var button = create('button', {\n        \"class\": classes.page,\n        type: 'button'\n      });\n      append(li, button);\n      append(list, li);\n      Splide.on('click', function () {\n        Splide.go(\">\" + page);\n      }, button);\n      return {\n        li: li,\n        button: button,\n        page: page,\n        Slides: Elements.getSlidesByPage(page)\n      };\n    });\n    return {\n      list: list,\n      items: items\n    };\n  }\n\n  return Pagination;\n});\n// CONCATENATED MODULE: ./src/js/components/lazyload/index.js\n/**\r\n * The component for loading slider images lazily.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The name for a data attribute of src.\r\n *\r\n * @type {string}\r\n */\n\nvar SRC_DATA_NAME = 'data-splide-lazy';\n/**\r\n * The name for a data attribute of srcset.\r\n *\r\n * @type {string}\r\n */\n\nvar SRCSET_DATA_NAME = 'data-splide-lazy-srcset';\n/**\r\n * The component for loading slider images lazily.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ var lazyload = (function (Splide, Components, name) {\n  /**\r\n   * Next index for sequential loading.\r\n   *\r\n   * @type {number}\r\n   */\n  var nextIndex;\n  /**\r\n   * Store objects containing an img element and a Slide object.\r\n   *\r\n   * @type {Object[]}\r\n   */\n\n  var images;\n  /**\r\n   * Store the options.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var options = Splide.options;\n  /**\r\n   * Whether to load images sequentially or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isSequential = options.lazyLoad === 'sequential';\n  /**\r\n   * Lazyload component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Lazyload = {\n    /**\r\n     * Mount only when the lazyload option is provided.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: options.lazyLoad,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('mounted refresh', function () {\n        init();\n        Components.Elements.each(function (Slide) {\n          each(Slide.slide.querySelectorAll(\"[\" + SRC_DATA_NAME + \"], [\" + SRCSET_DATA_NAME + \"]\"), function (img) {\n            if (!img.src && !img.srcset) {\n              images.push({\n                img: img,\n                Slide: Slide\n              });\n              applyStyle(img, {\n                display: 'none'\n              });\n            }\n          });\n        });\n\n        if (isSequential) {\n          loadNext();\n        }\n      });\n\n      if (!isSequential) {\n        Splide.on(\"mounted refresh moved.\" + name, check);\n      }\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: init\n  };\n  /**\r\n   * Initialize parameters.\r\n   */\n\n  function init() {\n    images = [];\n    nextIndex = 0;\n  }\n  /**\r\n   * Check how close each image is from the active slide and\r\n   * determine whether to start loading or not, according to the distance.\r\n   *\r\n   * @param {number} index - Current index.\r\n   */\n\n\n  function check(index) {\n    index = isNaN(index) ? Splide.index : index;\n    images = images.filter(function (image) {\n      if (image.Slide.isWithin(index, options.perPage * (options.preloadPages + 1))) {\n        load(image.img, image.Slide);\n        return false;\n      }\n\n      return true;\n    }); // Unbind if all images are loaded.\n\n    if (!images[0]) {\n      Splide.off(\"moved.\" + name);\n    }\n  }\n  /**\r\n   * Start loading an image.\r\n   * Creating a clone of the image element since setting src attribute directly to it\r\n   * often occurs 'hitch', blocking some other processes of a browser.\r\n   *\r\n   * @param {Element} img   - An image element.\r\n   * @param {Object}  Slide - A Slide object.\r\n   */\n\n\n  function load(img, Slide) {\n    addClass(Slide.slide, STATUS_CLASSES.loading);\n    var spinner = create('span', {\n      \"class\": Splide.classes.spinner\n    });\n    append(img.parentElement, spinner);\n\n    img.onload = function () {\n      loaded(img, spinner, Slide, false);\n    };\n\n    img.onerror = function () {\n      loaded(img, spinner, Slide, true);\n    };\n\n    setAttribute(img, 'srcset', getAttribute(img, SRCSET_DATA_NAME) || '');\n    setAttribute(img, 'src', getAttribute(img, SRC_DATA_NAME) || '');\n  }\n  /**\r\n   * Start loading a next image in images array.\r\n   */\n\n\n  function loadNext() {\n    if (nextIndex < images.length) {\n      var image = images[nextIndex];\n      load(image.img, image.Slide);\n    }\n\n    nextIndex++;\n  }\n  /**\r\n   * Called just after the image was loaded or loading was aborted by some error.\r\n   *\r\n   * @param {Element} img     - An image element.\r\n   * @param {Element} spinner - A spinner element.\r\n   * @param {Object}  Slide   - A Slide object.\r\n   * @param {boolean} error   - True if the image was loaded successfully or false on error.\r\n   */\n\n\n  function loaded(img, spinner, Slide, error) {\n    removeClass(Slide.slide, STATUS_CLASSES.loading);\n\n    if (!error) {\n      dom_remove(spinner);\n      applyStyle(img, {\n        display: ''\n      });\n      Splide.emit(name + \":loaded\", img).emit('resize');\n    }\n\n    if (isSequential) {\n      loadNext();\n    }\n  }\n\n  return Lazyload;\n});\n// CONCATENATED MODULE: ./src/js/constants/a11y.js\n/**\r\n * Export aria attribute names.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Attribute name for aria-current.\r\n *\r\n * @type {string}\r\n */\nvar ARIA_CURRENRT = 'aria-current';\n/**\r\n * Attribute name for aria-control.\r\n *\r\n * @type {string}\r\n */\n\nvar ARIA_CONTROLS = 'aria-controls';\n/**\r\n * Attribute name for aria-control.\r\n *\r\n * @type {string}\r\n */\n\nvar ARIA_LABEL = 'aria-label';\n/**\r\n * Attribute name for aria-labelledby.\r\n *\r\n * @type {string}\r\n */\n\nvar ARIA_LABELLEDBY = 'aria-labelledby';\n/**\r\n * Attribute name for aria-hidden.\r\n *\r\n * @type {string}\r\n */\n\nvar ARIA_HIDDEN = 'aria-hidden';\n/**\r\n * Attribute name for tab-index.\r\n *\r\n * @type {string}\r\n */\n\nvar TAB_INDEX = 'tabindex';\n// CONCATENATED MODULE: ./src/js/components/keyboard/index.js\n/**\r\n * The component for controlling slides via keyboard.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Map a key to a slide control.\r\n *\r\n * @type {Object}\r\n */\n\nvar KEY_MAP = {\n  ltr: {\n    ArrowLeft: '<',\n    ArrowRight: '>',\n    // For IE.\n    Left: '<',\n    Right: '>'\n  },\n  rtl: {\n    ArrowLeft: '>',\n    ArrowRight: '<',\n    // For IE.\n    Left: '>',\n    Right: '<'\n  },\n  ttb: {\n    ArrowUp: '<',\n    ArrowDown: '>',\n    // For IE.\n    Up: '<',\n    Down: '>'\n  }\n};\n/**\r\n * The component for controlling slides via keyboard.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ var components_keyboard = (function (Splide) {\n  /**\r\n   * Hold the target element.\r\n   *\r\n   * @type {Element|Document|undefined}\r\n   */\n  var target;\n  return {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('mounted updated', function () {\n        var options = Splide.options;\n        var root = Splide.root;\n        var map = KEY_MAP[options.direction];\n        var keyboard = options.keyboard;\n\n        if (target) {\n          Splide.off('keydown', target);\n          removeAttribute(root, TAB_INDEX);\n        }\n\n        if (keyboard) {\n          if (keyboard === 'focused') {\n            target = root;\n            setAttribute(root, TAB_INDEX, 0);\n          } else {\n            target = document;\n          }\n\n          Splide.on('keydown', function (e) {\n            if (map[e.key]) {\n              Splide.go(map[e.key]);\n            }\n          }, target);\n        }\n      });\n    }\n  };\n});\n// CONCATENATED MODULE: ./src/js/components/a11y/index.js\n/**\r\n * The component for enhancing accessibility.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The component for enhancing accessibility.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ var a11y = (function (Splide, Components) {\n  /**\r\n   * Hold a i18n object.\r\n   *\r\n   * @type {Object}\r\n   */\n  var i18n = Splide.i18n;\n  /**\r\n   * Hold the Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * All attributes related with A11y.\r\n   *\r\n   * @type {string[]}\r\n   */\n\n  var allAttributes = [ARIA_HIDDEN, TAB_INDEX, ARIA_CONTROLS, ARIA_LABEL, ARIA_CURRENRT, 'role'];\n  /**\r\n   * A11y component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var A11y = {\n    /**\r\n     * Required only when the accessibility option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: Splide.options.accessibility,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('visible', function (Slide) {\n        updateSlide(Slide.slide, true);\n      }).on('hidden', function (Slide) {\n        updateSlide(Slide.slide, false);\n      }).on('arrows:mounted', initArrows).on('arrows:updated', updateArrows).on('pagination:mounted', initPagination).on('pagination:updated', updatePagination).on('refresh', function () {\n        removeAttribute(Components.Clones.clones, allAttributes);\n      });\n\n      if (Splide.options.isNavigation) {\n        Splide.on('navigation:mounted', initNavigation).on('active', function (Slide) {\n          updateNavigation(Slide, true);\n        }).on('inactive', function (Slide) {\n          updateNavigation(Slide, false);\n        });\n      }\n\n      initAutoplay();\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      var Arrows = Components.Arrows;\n      var arrows = Arrows ? Arrows.arrows : {};\n      removeAttribute(Elements.slides.concat([arrows.prev, arrows.next, Elements.play, Elements.pause]), allAttributes);\n    }\n  };\n  /**\r\n   * Update slide attributes when it gets visible or hidden.\r\n   *\r\n   * @param {Element} slide   - A slide element.\r\n   * @param {Boolean} visible - True when the slide gets visible, or false when hidden.\r\n   */\n\n  function updateSlide(slide, visible) {\n    setAttribute(slide, ARIA_HIDDEN, !visible);\n\n    if (Splide.options.slideFocus) {\n      setAttribute(slide, TAB_INDEX, visible ? 0 : -1);\n    }\n  }\n  /**\r\n   * Initialize arrows if they are available.\r\n   * Append screen reader elements and add aria-controls attribute.\r\n   *\r\n   * @param {Element} prev - Previous arrow element.\r\n   * @param {Element} next - Next arrow element.\r\n   */\n\n\n  function initArrows(prev, next) {\n    var controls = Elements.track.id;\n    setAttribute(prev, ARIA_CONTROLS, controls);\n    setAttribute(next, ARIA_CONTROLS, controls);\n  }\n  /**\r\n   * Update arrow attributes.\r\n   *\r\n   * @param {Element} prev      - Previous arrow element.\r\n   * @param {Element} next      - Next arrow element.\r\n   * @param {number}  prevIndex - Previous slide index or -1 when there is no precede slide.\r\n   * @param {number}  nextIndex - Next slide index or -1 when there is no next slide.\r\n   */\n\n\n  function updateArrows(prev, next, prevIndex, nextIndex) {\n    var index = Splide.index;\n    var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;\n    var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;\n    setAttribute(prev, ARIA_LABEL, prevLabel);\n    setAttribute(next, ARIA_LABEL, nextLabel);\n  }\n  /**\r\n   * Initialize pagination if it's available.\r\n   * Append a screen reader element and add aria-controls/label attribute to each item.\r\n   *\r\n   * @param {Object} data       - Data object containing all items.\r\n   * @param {Object} activeItem - An initial active item.\r\n   */\n\n\n  function initPagination(data, activeItem) {\n    if (activeItem) {\n      setAttribute(activeItem.button, ARIA_CURRENRT, true);\n    }\n\n    data.items.forEach(function (item) {\n      var options = Splide.options;\n      var text = options.focus === false && options.perPage > 1 ? i18n.pageX : i18n.slideX;\n      var label = sprintf(text, item.page + 1);\n      var button = item.button;\n      var controls = item.Slides.map(function (Slide) {\n        return Slide.slide.id;\n      });\n      setAttribute(button, ARIA_CONTROLS, controls.join(' '));\n      setAttribute(button, ARIA_LABEL, label);\n    });\n  }\n  /**\r\n   * Update pagination attributes.\r\n   *\r\n   * @param {Object}  data - Data object containing all items.\r\n   * @param {Element} prev - A previous active element.\r\n   * @param {Element} curr - A current active element.\r\n   */\n\n\n  function updatePagination(data, prev, curr) {\n    if (prev) {\n      removeAttribute(prev.button, ARIA_CURRENRT);\n    }\n\n    if (curr) {\n      setAttribute(curr.button, ARIA_CURRENRT, true);\n    }\n  }\n  /**\r\n   * Initialize autoplay buttons.\r\n   */\n\n\n  function initAutoplay() {\n    ['play', 'pause'].forEach(function (name) {\n      var elm = Elements[name];\n\n      if (elm) {\n        if (!isButton(elm)) {\n          setAttribute(elm, 'role', 'button');\n        }\n\n        setAttribute(elm, ARIA_CONTROLS, Elements.track.id);\n        setAttribute(elm, ARIA_LABEL, i18n[name]);\n      }\n    });\n  }\n  /**\r\n   * Initialize navigation slider.\r\n   * Add button role, aria-label, aria-controls to slide elements and append screen reader text to them.\r\n   *\r\n   * @param {Splide} main - A main Splide instance.\r\n   */\n\n\n  function initNavigation(main) {\n    Elements.each(function (Slide) {\n      var slide = Slide.slide;\n      var realIndex = Slide.realIndex;\n\n      if (!isButton(slide)) {\n        setAttribute(slide, 'role', 'button');\n      }\n\n      var slideIndex = realIndex > -1 ? realIndex : Slide.index;\n      var label = sprintf(i18n.slideX, slideIndex + 1);\n      var mainSlide = main.Components.Elements.getSlide(slideIndex);\n      setAttribute(slide, ARIA_LABEL, label);\n\n      if (mainSlide) {\n        setAttribute(slide, ARIA_CONTROLS, mainSlide.slide.id);\n      }\n    });\n  }\n  /**\r\n   * Update navigation attributes.\r\n   *\r\n   * @param {Object}  Slide  - A target Slide object.\r\n   * @param {boolean} active - True if the slide is active or false if inactive.\r\n   */\n\n\n  function updateNavigation(_ref, active) {\n    var slide = _ref.slide;\n\n    if (active) {\n      setAttribute(slide, ARIA_CURRENRT, true);\n    } else {\n      removeAttribute(slide, ARIA_CURRENRT);\n    }\n  }\n  /**\r\n   * Check if the given element is button or not.\r\n   *\r\n   * @param {Element} elm - An element to be checked.\r\n   *\r\n   * @return {boolean} - True if the given element is button.\r\n   */\n\n\n  function isButton(elm) {\n    return elm.tagName === 'BUTTON';\n  }\n\n  return A11y;\n});\n// CONCATENATED MODULE: ./src/js/components/sync/index.js\n/**\r\n * The component for synchronizing a slider with another.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * The event name for sync.\r\n *\r\n * @type {string}\r\n */\n\nvar SYNC_EVENT = 'move.sync';\n/**\r\n * The keys for triggering the navigation button.\r\n *\r\n * @type {String[]}\r\n */\n\nvar TRIGGER_KEYS = [' ', 'Enter', 'Spacebar'];\n/**\r\n * The component for synchronizing a slider with another.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ var sync = (function (Splide) {\n  /**\r\n   * Keep the sibling Splide instance.\r\n   *\r\n   * @type {Splide}\r\n   */\n  var sibling = Splide.sibling;\n  /**\r\n   * Whether the sibling slider is navigation or not.\r\n   *\r\n   * @type {Splide|boolean}\r\n   */\n\n  var isNavigation = sibling && sibling.options.isNavigation;\n  /**\r\n   * Layout component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Sync = {\n    /**\r\n     * Required only when the sub slider is available.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: !!sibling,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      syncMain();\n      syncSibling();\n\n      if (isNavigation) {\n        bind();\n      }\n    },\n\n    /**\r\n     * Called after all components are mounted.\r\n     */\n    mounted: function mounted() {\n      if (isNavigation) {\n        sibling.emit('navigation:mounted', Splide);\n      }\n    }\n  };\n  /**\r\n   * Listen the primary slider event to move secondary one.\r\n   * Must unbind a handler at first to avoid infinite loop.\r\n   */\n\n  function syncMain() {\n    Splide.on(SYNC_EVENT, function (newIndex, prevIndex, destIndex) {\n      sibling.off(SYNC_EVENT).go(sibling.is(LOOP) ? destIndex : newIndex, false);\n      syncSibling();\n    });\n  }\n  /**\r\n   * Listen the secondary slider event to move primary one.\r\n   * Must unbind a handler at first to avoid infinite loop.\r\n   */\n\n\n  function syncSibling() {\n    sibling.on(SYNC_EVENT, function (newIndex, prevIndex, destIndex) {\n      Splide.off(SYNC_EVENT).go(Splide.is(LOOP) ? destIndex : newIndex, false);\n      syncMain();\n    });\n  }\n  /**\r\n   * Listen some events on each slide.\r\n   */\n\n\n  function bind() {\n    sibling.Components.Elements.each(function (_ref) {\n      var slide = _ref.slide,\n          index = _ref.index;\n\n      /*\r\n       * Listen mouseup and touchend events to handle click.\r\n       */\n      Splide.on('mouseup touchend', function (e) {\n        // Ignore a middle or right click.\n        if (!e.button || e.button === 0) {\n          moveSibling(index);\n        }\n      }, slide);\n      /*\r\n       * Subscribe keyup to handle Enter and Space key.\r\n       * Note that Array.includes is not supported by IE.\r\n       */\n\n      Splide.on('keyup', function (e) {\n        if (TRIGGER_KEYS.indexOf(e.key) > -1) {\n          e.preventDefault();\n          moveSibling(index);\n        }\n      }, slide, {\n        passive: false\n      });\n    });\n  }\n  /**\r\n   * Move the sibling to the given index.\r\n   * Need to check \"IDLE\" status because slides can be moving by Drag component.\r\n   *\r\n   * @param {number} index - Target index.\r\n   */\n\n\n  function moveSibling(index) {\n    if (Splide.State.is(IDLE)) {\n      sibling.go(index);\n    }\n  }\n\n  return Sync;\n});\n// CONCATENATED MODULE: ./src/js/components/breakpoints/index.js\n/**\r\n * The component for updating options according to a current window width.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Interval time for throttle.\r\n *\r\n * @type {number}\r\n */\n\nvar THROTTLE = 50;\n/**\r\n * The component for updating options according to a current window width.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ var components_breakpoints = (function (Splide) {\n  /**\r\n   * Store breakpoints.\r\n   *\r\n   * @type {Object|boolean}\r\n   */\n  var breakpoints = Splide.options.breakpoints;\n  /**\r\n   * The check function whose frequency of call is reduced.\r\n   *\r\n   * @type {Function}\r\n   */\n\n  var throttledCheck = throttle(check, THROTTLE);\n  /**\r\n   * Keep initial options.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var initialOptions;\n  /**\r\n   * An array containing objects of point and MediaQueryList.\r\n   *\r\n   * @type {Object[]}\r\n   */\n\n  var map = [];\n  /**\r\n   * Hold the previous breakpoint.\r\n   *\r\n   * @type {number|undefined}\r\n   */\n\n  var prevPoint;\n  /**\r\n   * Breakpoints component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Breakpoints = {\n    /**\r\n     * Required only when the breakpoints definition is provided and browser supports matchMedia.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: breakpoints && matchMedia,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      map = Object.keys(breakpoints).sort(function (n, m) {\n        return +n - +m;\n      }).map(function (point) {\n        return {\n          point: point,\n          mql: matchMedia(\"(max-width:\" + point + \"px)\")\n        };\n      });\n      /*\r\n       * To keep monitoring resize event after destruction without \"completely\",\r\n       * use native addEventListener instead of Splide.on.\r\n       */\n\n      this.destroy(true);\n      addEventListener('resize', throttledCheck); // Keep initial options to apply them when no breakpoint matches.\n\n      initialOptions = Splide.options;\n      check();\n    },\n\n    /**\r\n     * Destroy.\r\n     *\r\n     * @param {boolean} completely - Whether to destroy Splide completely.\r\n     */\n    destroy: function destroy(completely) {\n      if (completely) {\n        removeEventListener('resize', throttledCheck);\n      }\n    }\n  };\n  /**\r\n   * Check the breakpoint.\r\n   */\n\n  function check() {\n    var point = getPoint();\n\n    if (point !== prevPoint) {\n      prevPoint = point;\n      var State = Splide.State;\n      var options = breakpoints[point] || initialOptions;\n      var destroy = options.destroy;\n\n      if (destroy) {\n        Splide.options = initialOptions;\n        Splide.destroy(destroy === 'completely');\n      } else {\n        if (State.is(DESTROYED)) {\n          Splide.mount();\n        }\n\n        Splide.options = options;\n      }\n    }\n  }\n  /**\r\n   * Return the breakpoint matching current window width.\r\n   * Note that Array.prototype.find is not supported by IE.\r\n   *\r\n   * @return {number|string} - A breakpoint as number or string. -1 if no point matches.\r\n   */\n\n\n  function getPoint() {\n    var item = map.filter(function (item) {\n      return item.mql.matches;\n    })[0];\n    return item ? item.point : -1;\n  }\n\n  return Breakpoints;\n});\n// CONCATENATED MODULE: ./src/js/components/index.js\n/**\r\n * Export components.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar COMPLETE = {\n  Options: components_options,\n  Breakpoints: components_breakpoints,\n  Controller: controller,\n  Elements: components_elements,\n  Track: components_track,\n  Clones: components_clones,\n  Layout: layout,\n  Drag: drag,\n  Click: click,\n  Autoplay: components_autoplay,\n  Cover: components_cover,\n  Arrows: components_arrows,\n  Pagination: components_pagination,\n  LazyLoad: lazyload,\n  Keyboard: components_keyboard,\n  Sync: sync,\n  A11y: a11y\n};\nvar LIGHT = {\n  Options: components_options,\n  Controller: controller,\n  Elements: components_elements,\n  Track: components_track,\n  Clones: components_clones,\n  Layout: layout,\n  Drag: drag,\n  Click: click,\n  Arrows: components_arrows,\n  Pagination: components_pagination,\n  A11y: a11y\n};\n// CONCATENATED MODULE: ./build/module/module.js\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\r\n * Export Splide class for import.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Export Splide class for import from other projects.\r\n */\n\nvar module_Splide = /*#__PURE__*/function (_Core) {\n  _inheritsLoose(Splide, _Core);\n\n  function Splide(root, options) {\n    return _Core.call(this, root, options, COMPLETE) || this;\n  }\n\n  return Splide;\n}(splide_Splide);\n\n\n\n/***/ })\n/******/ ]);\n});","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal';\nexport { get_store_value as get } from '../internal';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe,\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = [];\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (let i = 0; i < subscribers.length; i += 1) {\n                    const s = subscribers[i];\n                    s[1]();\n                    subscriber_queue.push(s, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.push(subscriber);\n        if (subscribers.length === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            const index = subscribers.indexOf(subscriber);\n            if (index !== -1) {\n                subscribers.splice(index, 1);\n            }\n            if (subscribers.length === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","import { writable } from \"svelte/store\";\r\n\r\nexport const groups = writable({});\r\n","<script>\r\n  import { onMount, onDestroy } from \"svelte\";\r\n  import Splide from \"@splidejs/splide\";\r\n  import { groups } from \"./lib/store\";\r\n\r\n  export let splide;\r\n  export let autoHideArrows;\r\n  export let autoHideArrowsOffset = 0;\r\n  export let currentIndex;\r\n  export let group;\r\n  export let options = {};\r\n  export let extensions;\r\n  export let transition;\r\n\r\n  const SYNC_EVENT = \"move.svelte-splide-sync\";\r\n\r\n  let element;\r\n\r\n  $: if (options) {\r\n    splide && splide.refresh();\r\n  }\r\n\r\n  $: if (splide && options && options.arrows != false && autoHideArrows) {\r\n    checkLeftArrow(currentIndex == 0);\r\n    checkRightArrow(currentIndex >= splide.length - 1 - autoHideArrowsOffset);\r\n  }\r\n\r\n  $: if (splide && group) {\r\n    if (!$groups[group] || !$groups[group].includes(splide)) {\r\n      $groups[group] = $groups[group] ? [...$groups[group], splide] : [splide];\r\n    }\r\n\r\n    splide.off(SYNC_EVENT).on(SYNC_EVENT, moveGroup);\r\n  }\r\n\r\n  $: splide && splide.mount(extensions, transition);\r\n\r\n  function moveGroup(newIndex, prevIndex, destIndex) {\r\n    $groups[group].map((el) =>\r\n      el\r\n        .off(SYNC_EVENT)\r\n        .go(el.is(\"loop\") ? destIndex : newIndex, false)\r\n        .on(SYNC_EVENT, moveGroup)\r\n    );\r\n  }\r\n\r\n  function checkLeftArrow(hide) {\r\n    const arrow = element.querySelector(\r\n      \"button.splide__arrow.splide__arrow--prev\"\r\n    );\r\n    arrow.style.display = hide ? \"none\" : \"block\";\r\n  }\r\n\r\n  function checkRightArrow(hide) {\r\n    const arrow = element.querySelector(\r\n      \"button.splide__arrow.splide__arrow--next\"\r\n    );\r\n    arrow.style.display = hide ? \"none\" : \"block\";\r\n  }\r\n\r\n  onMount(() => {\r\n    splide = new Splide.default(element, options);\r\n\r\n    splide.on(\"move.svelte-splide\", (newIndex, oldIndex, destIndex) => {\r\n      currentIndex = splide.is(\"loop\") ? destIndex : newIndex;\r\n    });\r\n\r\n    splide.mount(extensions, transition);\r\n\r\n    currentIndex = splide.index;\r\n  });\r\n\r\n  onDestroy(() => {\r\n    if (group) {\r\n      $groups[group] = $groups[group].filter((el) => el != splide);\r\n    }\r\n\r\n    splide && splide.destroy();\r\n  });\r\n</script>\r\n\r\n<svelte:options accessors />\r\n\r\n<div class=\"splide\" bind:this={element}>\r\n  <div class=\"splide__track\">\r\n    <ul class=\"splide__list\">\r\n      <slot />\r\n    </ul>\r\n  </div>\r\n</div>\r\n","<script>\r\n  import \"@splidejs/splide/dist/css/splide.min.css\";\r\n  import { Splide, SplideSlide } from \"@fiorelorenzo/svelte-splide\";\r\n\r\n  const options = {\r\n    arrows: true,\r\n    pagination: false,\r\n    autoWidth: true,\r\n    rewind: false,\r\n    gap: 50,\r\n  };\r\n\r\n  const autoHideArrowsOffset = 2;\r\n\r\n  let defaultCurrentIndex;\r\n  let autoWidthCurrentIndex;\r\n  let autoWidthAutoHideArrowsCurrentIndex;\r\n  let groupCurrentIndex;\r\n</script>\r\n\r\n<style>\r\n  main {\r\n    margin-bottom: 100px;\r\n  }\r\n</style>\r\n\r\n<main>\r\n  <h1>Default</h1>\r\n  <p>Current index: {defaultCurrentIndex}</p>\r\n\r\n  <Splide bind:currentIndex={defaultCurrentIndex}>\r\n    {#each Array(10) as i}\r\n      <SplideSlide>\r\n        <img\r\n          src=\"https://via.placeholder.com/540x360\"\r\n          alt={`splide-slide-${i}`} />\r\n      </SplideSlide>\r\n    {/each}\r\n  </Splide>\r\n\r\n  <br />\r\n  <hr />\r\n\r\n  <h1><i>autoWidth</i></h1>\r\n  <p>Current index: {autoWidthCurrentIndex}</p>\r\n\r\n  <Splide {options} bind:currentIndex={autoWidthCurrentIndex}>\r\n    {#each Array(10) as i}\r\n      <SplideSlide>\r\n        <img\r\n          src=\"https://via.placeholder.com/540x360\"\r\n          alt={`splide-slide-${i}`} />\r\n      </SplideSlide>\r\n    {/each}\r\n  </Splide>\r\n\r\n  <br />\r\n  <hr />\r\n\r\n  <h1><i>autoWidth</i> and <i>autoHideArrows</i></h1>\r\n  <p>Current index: {autoWidthAutoHideArrowsCurrentIndex}</p>\r\n\r\n  <Splide\r\n    {options}\r\n    autoHideArrows\r\n    {autoHideArrowsOffset}\r\n    bind:currentIndex={autoWidthAutoHideArrowsCurrentIndex}>\r\n    {#each Array(10) as i}\r\n      <SplideSlide>\r\n        <img\r\n          src=\"https://via.placeholder.com/540x360\"\r\n          alt={`splide-slide-${i}`} />\r\n      </SplideSlide>\r\n    {/each}\r\n  </Splide>\r\n\r\n  <br />\r\n  <hr />\r\n\r\n  <h1>Group syncing</h1>\r\n  <p>Current index: {groupCurrentIndex}</p>\r\n\r\n  <Splide\r\n    {options}\r\n    autoHideArrows\r\n    {autoHideArrowsOffset}\r\n    group=\"demo\"\r\n    bind:currentIndex={groupCurrentIndex}>\r\n    {#each Array(10) as i}\r\n      <SplideSlide>\r\n        <img\r\n          src=\"https://via.placeholder.com/540x360\"\r\n          alt={`splide-slide-${i}`} />\r\n      </SplideSlide>\r\n    {/each}\r\n  </Splide>\r\n  <br />\r\n  <Splide {options} autoHideArrows {autoHideArrowsOffset} group=\"demo\">\r\n    {#each Array(10) as i}\r\n      <SplideSlide>\r\n        <img\r\n          src=\"https://via.placeholder.com/540x360\"\r\n          alt={`splide-slide-${i}`} />\r\n      </SplideSlide>\r\n    {/each}\r\n  </Splide>\r\n  <br />\r\n  <Splide {options} autoHideArrows {autoHideArrowsOffset} group=\"demo\">\r\n    {#each Array(10) as i}\r\n      <SplideSlide>\r\n        <img\r\n          src=\"https://via.placeholder.com/540x360\"\r\n          alt={`splide-slide-${i}`} />\r\n      </SplideSlide>\r\n    {/each}\r\n  </Splide>\r\n</main>\r\n","import App from './App.svelte';\r\n\r\nconst app = new App({\r\n\ttarget: document.body,\r\n\tprops: {\r\n\t\tname: 'world'\r\n\t}\r\n});\r\n\r\nexport default app;"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","component_subscribe","component","store","callback","$$","on_destroy","push","callbacks","unsub","subscribe","unsubscribe","create_slot","definition","ctx","$$scope","slot_ctx","get_slot_context","tar","src","k","assign","slice","update_slot","slot","slot_definition","dirty","get_slot_changes_fn","get_slot_context_fn","slot_changes","lets","undefined","merged","len","Math","max","length","i","get_slot_changes","slot_context","p","set_store_value","ret","value","set","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","destroy_each","iterations","detaching","d","element","name","document","createElement","text","data","createTextNode","space","empty","attr","attribute","removeAttribute","getAttribute","setAttribute","set_data","wholeText","current_component","set_current_component","get_current_component","Error","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","add_flush_callback","flushing","seen_callbacks","Set","flush","update","pop","has","add","clear","fragment","before_update","after_update","outroing","outros","group_outros","r","c","check_outros","transition_in","block","local","delete","transition_out","o","bind","index","props","bound","create_component","mount_component","on_mount","m","new_on_destroy","map","filter","destroy_component","make_dirty","then","fill","init","options","instance","create_fragment","not_equal","parent_component","prop_values","context","Map","skip_bound","ready","rest","hydrate","nodes","Array","from","childNodes","children","l","intro","SvelteComponent","[object Object]","this","$destroy","type","indexOf","splice","$$props","obj","$$set","keys","css","ref","insertAt","head","getElementsByTagName","style","firstChild","styleSheet","cssText","factory","window","modules","installedModules","__webpack_require__","moduleId","exports","module","call","getter","defineProperty","enumerable","get","Symbol","toStringTag","t","mode","__esModule","ns","key","n","object","property","prototype","hasOwnProperty","s","__webpack_exports__","module_Splide","states_namespaceObject","_extends","arguments","source","apply","CREATED","MOUNTED","IDLE","MOVING","DESTROYED","each","some","values","isObject","subject","merge","_ref","to","toArray","isArray","between","m1","m2","min","sprintf","format","replacements","replace","unit","parseFloat","pad","number","toPixel","root","div","applyStyle","position","width","clientWidth","dom_remove","find","elm","selector","querySelector","split","child","parent","tagOrClassName","hasClass","tagName","tag","attrs","domify","html","innerHTML","elms","parentElement","before","styles","prop","addOrRemoveClasses","classes","remove","classList","addClass","removeClass","className","contains","names","getRect","getBoundingClientRect","SLIDE","LOOP","FADE","transitions_slide","Splide","Components","list","endCallback","mount","Elements","on","e","start","destIndex","newIndex","prevIndex","coord","done","edgeIndex","Controller","speed","is","rewindSpeed","transition","easing","transform","x","y","fade","slides","track","height","clientHeight","setTimeout","error_error","message","console","error","MESSAGE_PREFIX","exist","ROOT","STATUS_CLASSES","active","visible","loading","DEFAULTS","rewind","waitForTransition","fixedWidth","fixedHeight","heightRatio","autoWidth","autoHeight","perPage","perMove","clones","focus","gap","padding","arrows","arrowPath","pagination","autoplay","interval","pauseOnHover","pauseOnFocus","resetProgress","lazyLoad","preloadPages","keyboard","drag","dragAngleThreshold","swipeDistanceThreshold","flickVelocityThreshold","flickPower","flickMaxPages","direction","cover","accessibility","slideFocus","isNavigation","trimSpace","updateOnMove","throttle","destroy","breakpoints","slider","slide","container","arrow","prev","next","page","clone","progress","bar","play","pause","spinner","sr","i18n","first","last","slideX","pageX","_defineProperties","descriptor","configurable","writable","splide_Splide","curr","Element","Event","item","removeEventListener","event","handler","events","addEventListener","off","emit","_len","args","_key","core_event","State","state","STATES","_o","_i","_c","_e","_t","Constructor","protoProps","staticProps","_proto","Extensions","Transition","_this","components","Component","toLowerCase","compose","required","mounted","visibility","sync","splide","sibling","_this$Event","concat","go","control","wait","refresh","completely","_this2","reverse","parseInt","created","RTL","TTB","STYLE_RESTORE_EVENTS","floor","abs","func","timeout","drag_abs","PAUSE_FLAGS","ATTRIBUTES_UPDATE_EVENT","UPDATE_EVENT","SRC_DATA_NAME","SRCSET_DATA_NAME","ARIA_CURRENRT","ARIA_CONTROLS","ARIA_LABEL","ARIA_HIDDEN","TAB_INDEX","KEY_MAP","ltr","ArrowLeft","ArrowRight","Left","Right","rtl","ttb","ArrowUp","ArrowDown","Up","Down","SYNC_EVENT","TRIGGER_KEYS","COMPLETE","Options","JSON","parse","Breakpoints","initialOptions","prevPoint","throttledCheck","check","point","mql","matches","matchMedia","sort","isLoop","newOptions","silently","trim","Track","String","match","indicator","toIndex","sign","toPage","parsePage","hasFocus","pageLength","edge","isRtl","ceil","nextIndex","Slides","id","uid","getClasses","Slide","findParts","collect","register","realIndex","SlideObject","STATUS_UPDATE_EVENTS","isClone","restoreStyles","_update","display","isActive","isVisible","trackRect","slideRect","top","bottom","left","right","isWithin","within","diff","forVisibility","elements_slide","getSlide","getSlides","includeClones","getSlidesByPage","idx","images","querySelectorAll","count","img","onload","onerror","dom_loaded","total","rootClass","Layout","isVertical","isFade","isRTL","isLoopPending","jump","newPosition","getTrimmedPosition","toCoord","onTransitionEnd","translate","cancel","shift","toPosition","innerSize","totalSize","size","minDistance","Infinity","slideIndex","distance","slideSize","offset","Clones","cloneCount","getCloneCount","cloneDeeply","generateClones","baseCount","dimension","fixedSize","cloneNode","resize","totalHeight","totalWidth","slideHeight","slideWidth","margin","paddingTop","paddingBottom","offsetHeight","vertical","paddingLeft","paddingRight","listRect","offsetWidth","horizontal","getOwnPropertyDescriptor","maxWidth","Drag","startCoord","startInfo","currentInfo","isDragging","axis","disabled","move","passive","end","preventDefault","analyze","cancelable","_start","_end","log","resist","angle","atan","PI","shouldMove","info","velocity","absV","destination","timeStamp","touches","_ref2","clientX","clientY","_ref3","_ref3$x","fromX","_ref3$y","duration","time","Click","onClick","stopPropagation","stopImmediatePropagation","capture","Autoplay","flags","elapse","rate","requestAnimationFrame","_pause","step","timestamp","reset","createInterval","switchOn","flag","f","Cover","uncover","background","Arrows","updateDisabled","_Components$Controlle","isEnough","createArrow","wrapper","class","firstElementChild","appendArrows","Pagination","items","li","button","updateAttributes","getItem","LazyLoad","isSequential","isNaN","image","load","loaded","loadNext","srcset","Keyboard","Sync","syncMain","syncSibling","moveSibling","A11y","allAttributes","updateSlide","initArrows","controls","updateArrows","prevLabel","nextLabel","initPagination","activeItem","label","join","updatePagination","initNavigation","main","isButton","mainSlide","updateNavigation","_Core","subClass","superClass","constructor","__proto__","subscriber_queue","groups","stop","subscribers","new_value","run_queue","invalidate","subscriber","autoHideArrows","autoHideArrowsOffset","currentIndex","group","extensions","moveGroup","$groups","el","onMount","default","oldIndex","onDestroy","hide","checkRightArrow","includes","defaultCurrentIndex","autoWidthCurrentIndex","autoWidthAutoHideArrowsCurrentIndex","groupCurrentIndex","body"],"mappings":"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"}